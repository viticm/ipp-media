//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 2004 - 2012 Intel Corporation. All Rights Reserved.
//

#include "umc_config.h"
#ifdef UMC_ENABLE_H264_VIDEO_ENCODER

#include <string.h>
#include "umc_base_bitstream.h"
#include "umc_h264_bs.h"
#include "umc_h264_config.h"
#include "umc_h264_tables.h"

// ---------------------------------------------------------------------------
//  CBaseBitstream::CBaseBitstream()
//      Default constructor.
// ---------------------------------------------------------------------------

const Ipp8u renormTAB[32] = {6,5, 4,4,3,3,3,3, 2,2,2,2,2,2,2,2, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 };

// Range table
const Ipp8u rangeTabLPS[128][4]=
{
    { 128, 176, 208, 240},
    { 128, 167, 197, 227},
    { 128, 158, 187, 216},
    { 123, 150, 178, 205},
    { 116, 142, 169, 195},
    { 111, 135, 160, 185},
    { 105, 128, 152, 175},
    { 100, 122, 144, 166},
    {  95, 116, 137, 158},
    {  90, 110, 130, 150},
    {  85, 104, 123, 142},
    {  81,  99, 117, 135},
    {  77,  94, 111, 128},
    {  73,  89, 105, 122},
    {  69,  85, 100, 116},
    {  66,  80,  95, 110},
    {  62,  76,  90, 104},
    {  59,  72,  86,  99},
    {  56,  69,  81,  94},
    {  53,  65,  77,  89},
    {  51,  62,  73,  85},
    {  48,  59,  69,  80},
    {  46,  56,  66,  76},
    {  43,  53,  63,  72},
    {  41,  50,  59,  69},
    {  39,  48,  56,  65},
    {  37,  45,  54,  62},
    {  35,  43,  51,  59},
    {  33,  41,  48,  56},
    {  32,  39,  46,  53},
    {  30,  37,  43,  50},
    {  29,  35,  41,  48},
    {  27,  33,  39,  45},
    {  26,  31,  37,  43},
    {  24,  30,  35,  41},
    {  23,  28,  33,  39},
    {  22,  27,  32,  37},
    {  21,  26,  30,  35},
    {  20,  24,  29,  33},
    {  19,  23,  27,  31},
    {  18,  22,  26,  30},
    {  17,  21,  25,  28},
    {  16,  20,  23,  27},
    {  15,  19,  22,  25},
    {  14,  18,  21,  24},
    {  14,  17,  20,  23},
    {  13,  16,  19,  22},
    {  12,  15,  18,  21},
    {  12,  14,  17,  20},
    {  11,  14,  16,  19},
    {  11,  13,  15,  18},
    {  10,  12,  15,  17},
    {  10,  12,  14,  16},
    {   9,  11,  13,  15},
    {   9,  11,  12,  14},
    {   8,  10,  12,  14},
    {   8,   9,  11,  13},
    {   7,   9,  11,  12},
    {   7,   9,  10,  12},
    {   7,   8,  10,  11},
    {   6,   8,   9,  11},
    {   6,   7,   9,  10},
    {   6,   7,   8,   9},
    {   2,   2,   2,   2},
//The same for valMPS=1
    { 128, 176, 208, 240},
    { 128, 167, 197, 227},
    { 128, 158, 187, 216},
    { 123, 150, 178, 205},
    { 116, 142, 169, 195},
    { 111, 135, 160, 185},
    { 105, 128, 152, 175},
    { 100, 122, 144, 166},
    {  95, 116, 137, 158},
    {  90, 110, 130, 150},
    {  85, 104, 123, 142},
    {  81,  99, 117, 135},
    {  77,  94, 111, 128},
    {  73,  89, 105, 122},
    {  69,  85, 100, 116},
    {  66,  80,  95, 110},
    {  62,  76,  90, 104},
    {  59,  72,  86,  99},
    {  56,  69,  81,  94},
    {  53,  65,  77,  89},
    {  51,  62,  73,  85},
    {  48,  59,  69,  80},
    {  46,  56,  66,  76},
    {  43,  53,  63,  72},
    {  41,  50,  59,  69},
    {  39,  48,  56,  65},
    {  37,  45,  54,  62},
    {  35,  43,  51,  59},
    {  33,  41,  48,  56},
    {  32,  39,  46,  53},
    {  30,  37,  43,  50},
    {  29,  35,  41,  48},
    {  27,  33,  39,  45},
    {  26,  31,  37,  43},
    {  24,  30,  35,  41},
    {  23,  28,  33,  39},
    {  22,  27,  32,  37},
    {  21,  26,  30,  35},
    {  20,  24,  29,  33},
    {  19,  23,  27,  31},
    {  18,  22,  26,  30},
    {  17,  21,  25,  28},
    {  16,  20,  23,  27},
    {  15,  19,  22,  25},
    {  14,  18,  21,  24},
    {  14,  17,  20,  23},
    {  13,  16,  19,  22},
    {  12,  15,  18,  21},
    {  12,  14,  17,  20},
    {  11,  14,  16,  19},
    {  11,  13,  15,  18},
    {  10,  12,  15,  17},
    {  10,  12,  14,  16},
    {   9,  11,  13,  15},
    {   9,  11,  12,  14},
    {   8,  10,  12,  14},
    {   8,   9,  11,  13},
    {   7,   9,  11,  12},
    {   7,   9,  10,  12},
    {   7,   8,  10,  11},
    {   6,   8,   9,  11},
    {   6,   7,   9,  10},
    {   6,   7,   8,   9},
    {   2,   2,   2,   2}
};

const Ipp16u transIdxMPS[64] =
{
    1,2,3,4,5,6,7,8,9,10,          // Trans
    11,12,13,14,15,16,17,18,19,20, // index
    21,22,23,24,25,26,27,28,29,30, // array.
    31,32,33,34,35,36,37,38,39,40, // Needed
    41,42,43,44,45,46,47,48,49,50, // for
    51,52,53,54,55,56,57,58,59,60, // CABAC
    61,62,62,63                    // coding.
};


const Ipp16u transIdxLPS[64] =
{
    0, 0, 1, 2, 2, 4, 4, 5, 6, 7,  // Trans
    8, 9, 9,11,11,12,13,13,15,15,  // index
    16,16,18,18,19,19,21,21,22,22, // array.
    23,24,24,25,26,26,27,27,28,29, // Needed
    29,30,30,30,31,32,32,33,33,33, // for
    34,34,35,35,35,36,36,36,37,37, // CABAC
    37,38,38,63                    // coding.
};

const Ipp32u bitcount_EG0[268] = {
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  256,  768,  768,
1280, 1280, 1280, 1280, 1792, 1792, 1792, 1792, 1792, 1792, 1792, 1792, 2304, 2304, 2304, 2304,
2304, 2304, 2304, 2304, 2304, 2304, 2304, 2304, 2304, 2304, 2304, 2304, 2816, 2816, 2816, 2816,
2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816,
2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 2816, 3328, 3328, 3328, 3328,
3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328,
3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328,
3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328,
3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3328, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840,
};

const Ipp32u bitcount_EG3[263] = {
   0,    0,    0,    0,    0,    0,    0,    0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536,
2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560,
2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560,
2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560,
2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072, 3072,
3584, 3584, 3584, 3584, 3584, 3584, 3584,
};

__ALIGN8 const Ipp8u pref_state[128][16] =
{
{ 1, 0, 64, 65, 66, 66, 68, 68, 69, 70, 71, 72, 73, 76, 0, 0, },
{ 2, 1, 0, 64, 65, 66, 66, 68, 68, 69, 70, 71, 72, 75, 0, 0, },
{ 3, 2, 1, 0, 64, 65, 66, 66, 68, 68, 69, 70, 71, 74, 0, 0, },
{ 4, 3, 2, 1, 0, 64, 65, 66, 66, 68, 68, 69, 70, 73, 0, 0, },
{ 5, 3, 2, 1, 0, 64, 65, 66, 66, 68, 68, 69, 70, 73, 0, 0, },
{ 6, 5, 3, 2, 1, 0, 64, 65, 66, 66, 68, 68, 69, 72, 0, 0, },
{ 7, 5, 3, 2, 1, 0, 64, 65, 66, 66, 68, 68, 69, 72, 0, 0, },
{ 8, 6, 5, 3, 2, 1, 0, 64, 65, 66, 66, 68, 68, 71, 0, 0, },
{ 9, 7, 5, 3, 2, 1, 0, 64, 65, 66, 66, 68, 68, 71, 0, 0, },
{ 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 66, 66, 68, 70, 0, 0, },
{ 11, 9, 7, 5, 3, 2, 1, 0, 64, 65, 66, 66, 68, 70, 0, 0, },
{ 12, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 66, 66, 69, 0, 0, },
{ 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 66, 66, 69, 0, 0, },
{ 14, 12, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 66, 68, 0, 0, },
{ 15, 12, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 66, 68, 0, 0, },
{ 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 66, 68, 0, 0, },
{ 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 67, 0, 0, },
{ 18, 14, 12, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 67, 0, 0, },
{ 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 67, 0, 0, },
{ 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 65, 67, 0, 0, },
{ 21, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 0, 64, 66, 0, 0, },
{ 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 0, 64, 66, 0, 0, },
{ 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 66, 0, 0, },
{ 24, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 66, 0, 0, },
{ 25, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 66, 0, 0, },
{ 26, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 64, 66, 0, 0, },
{ 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 29, 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 30, 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 31, 24, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 32, 25, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 33, 25, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 34, 26, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 0, 65, 0, 0, },
{ 35, 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 36, 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 37, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 38, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 39, 29, 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 40, 30, 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 41, 30, 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 42, 31, 24, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 43, 31, 24, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 44, 31, 24, 19, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 45, 32, 25, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 46, 33, 25, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 47, 33, 25, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 48, 34, 26, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 49, 34, 26, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 50, 34, 26, 20, 16, 13, 10, 8, 6, 5, 3, 2, 1, 64, 0, 0, },
{ 51, 35, 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 52, 35, 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 53, 36, 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 54, 36, 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 55, 36, 27, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 56, 37, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 57, 37, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 58, 37, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 59, 38, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 60, 38, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 61, 38, 28, 22, 17, 14, 12, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 62, 39, 29, 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 62, 39, 29, 23, 19, 16, 13, 10, 8, 6, 5, 3, 2, 0, 0, 0, },
{ 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 0, 0, },
{ 0, 64, 65, 66, 66, 68, 68, 69, 70, 71, 72, 73, 73, 77, 0, 0, },
{ 64, 65, 66, 66, 68, 68, 69, 70, 71, 72, 73, 73, 75, 78, 0, 0, },
{ 65, 66, 66, 68, 68, 69, 70, 71, 72, 73, 73, 75, 75, 79, 0, 0, },
{ 66, 66, 68, 68, 69, 70, 71, 72, 73, 73, 75, 75, 76, 80, 0, 0, },
{ 66, 68, 68, 69, 70, 71, 72, 73, 73, 75, 75, 76, 77, 81, 0, 0, },
{ 68, 68, 69, 70, 71, 72, 73, 73, 75, 75, 76, 77, 77, 82, 0, 0, },
{ 68, 69, 70, 71, 72, 73, 73, 75, 75, 76, 77, 77, 79, 83, 0, 0, },
{ 69, 70, 71, 72, 73, 73, 75, 75, 76, 77, 77, 79, 79, 84, 0, 0, },
{ 70, 71, 72, 73, 73, 75, 75, 76, 77, 77, 79, 79, 80, 85, 0, 0, },
{ 71, 72, 73, 73, 75, 75, 76, 77, 77, 79, 79, 80, 80, 86, 0, 0, },
{ 72, 73, 73, 75, 75, 76, 77, 77, 79, 79, 80, 80, 82, 87, 0, 0, },
{ 73, 73, 75, 75, 76, 77, 77, 79, 79, 80, 80, 82, 82, 88, 0, 0, },
{ 73, 75, 75, 76, 77, 77, 79, 79, 80, 80, 82, 82, 83, 89, 0, 0, },
{ 75, 75, 76, 77, 77, 79, 79, 80, 80, 82, 82, 83, 83, 90, 0, 0, },
{ 75, 76, 77, 77, 79, 79, 80, 80, 82, 82, 83, 83, 85, 91, 0, 0, },
{ 76, 77, 77, 79, 79, 80, 80, 82, 82, 83, 83, 85, 85, 92, 0, 0, },
{ 77, 77, 79, 79, 80, 80, 82, 82, 83, 83, 85, 85, 86, 93, 0, 0, },
{ 77, 79, 79, 80, 80, 82, 82, 83, 83, 85, 85, 86, 86, 94, 0, 0, },
{ 79, 79, 80, 80, 82, 82, 83, 83, 85, 85, 86, 86, 87, 95, 0, 0, },
{ 79, 80, 80, 82, 82, 83, 83, 85, 85, 86, 86, 87, 88, 96, 0, 0, },
{ 80, 80, 82, 82, 83, 83, 85, 85, 86, 86, 87, 88, 88, 97, 0, 0, },
{ 80, 82, 82, 83, 83, 85, 85, 86, 86, 87, 88, 88, 89, 98, 0, 0, },
{ 82, 82, 83, 83, 85, 85, 86, 86, 87, 88, 88, 89, 90, 99, 0, 0, },
{ 82, 83, 83, 85, 85, 86, 86, 87, 88, 88, 89, 90, 90, 100, 0, 0, },
{ 83, 83, 85, 85, 86, 86, 87, 88, 88, 89, 90, 90, 91, 101, 0, 0, },
{ 83, 85, 85, 86, 86, 87, 88, 88, 89, 90, 90, 91, 91, 102, 0, 0, },
{ 85, 85, 86, 86, 87, 88, 88, 89, 90, 90, 91, 91, 92, 103, 0, 0, },
{ 85, 86, 86, 87, 88, 88, 89, 90, 90, 91, 91, 92, 93, 104, 0, 0, },
{ 86, 86, 87, 88, 88, 89, 90, 90, 91, 91, 92, 93, 93, 105, 0, 0, },
{ 86, 87, 88, 88, 89, 90, 90, 91, 91, 92, 93, 93, 94, 106, 0, 0, },
{ 87, 88, 88, 89, 90, 90, 91, 91, 92, 93, 93, 94, 94, 107, 0, 0, },
{ 88, 88, 89, 90, 90, 91, 91, 92, 93, 93, 94, 94, 94, 108, 0, 0, },
{ 88, 89, 90, 90, 91, 91, 92, 93, 93, 94, 94, 94, 95, 109, 0, 0, },
{ 89, 90, 90, 91, 91, 92, 93, 93, 94, 94, 94, 95, 96, 110, 0, 0, },
{ 90, 90, 91, 91, 92, 93, 93, 94, 94, 94, 95, 96, 96, 111, 0, 0, },
{ 90, 91, 91, 92, 93, 93, 94, 94, 94, 95, 96, 96, 97, 112, 0, 0, },
{ 91, 91, 92, 93, 93, 94, 94, 94, 95, 96, 96, 97, 97, 113, 0, 0, },
{ 91, 92, 93, 93, 94, 94, 94, 95, 96, 96, 97, 97, 97, 114, 0, 0, },
{ 92, 93, 93, 94, 94, 94, 95, 96, 96, 97, 97, 97, 98, 115, 0, 0, },
{ 93, 93, 94, 94, 94, 95, 96, 96, 97, 97, 97, 98, 98, 116, 0, 0, },
{ 93, 94, 94, 94, 95, 96, 96, 97, 97, 97, 98, 98, 99, 117, 0, 0, },
{ 94, 94, 94, 95, 96, 96, 97, 97, 97, 98, 98, 99, 99, 118, 0, 0, },
{ 94, 94, 95, 96, 96, 97, 97, 97, 98, 98, 99, 99, 99, 119, 0, 0, },
{ 94, 95, 96, 96, 97, 97, 97, 98, 98, 99, 99, 99, 100, 120, 0, 0, },
{ 95, 96, 96, 97, 97, 97, 98, 98, 99, 99, 99, 100, 100, 121, 0, 0, },
{ 96, 96, 97, 97, 97, 98, 98, 99, 99, 99, 100, 100, 100, 122, 0, 0, },
{ 96, 97, 97, 97, 98, 98, 99, 99, 99, 100, 100, 100, 101, 123, 0, 0, },
{ 97, 97, 97, 98, 98, 99, 99, 99, 100, 100, 100, 101, 101, 124, 0, 0, },
{ 97, 97, 98, 98, 99, 99, 99, 100, 100, 100, 101, 101, 101, 125, 0, 0, },
{ 97, 98, 98, 99, 99, 99, 100, 100, 100, 101, 101, 101, 102, 126, 0, 0, },
{ 98, 98, 99, 99, 99, 100, 100, 100, 101, 101, 101, 102, 102, 126, 0, 0, },
{ 98, 99, 99, 99, 100, 100, 100, 101, 101, 101, 102, 102, 102, 126, 0, 0, },
{ 99, 99, 99, 100, 100, 100, 101, 101, 101, 102, 102, 102, 102, 126, 0, 0, },
{ 99, 99, 100, 100, 100, 101, 101, 101, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 99, 100, 100, 100, 101, 101, 101, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 100, 100, 100, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 100, 100, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 100, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 101, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 126, 0, 0, },
{ 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 0, 0, },
};

const Ipp32s pref_bits[128][16] =
{
{ 246, 532, 794, 1040, 1278, 1504, 1715, 1914, 2099, 2275, 2443, 2601, 2748, 2402, 0, 0, },
{ 232, 528, 814, 1076, 1322, 1560, 1786, 1997, 2196, 2381, 2557, 2725, 2883, 2562, 0, 0, },
{ 220, 528, 824, 1110, 1372, 1618, 1856, 2082, 2293, 2492, 2677, 2853, 3021, 2729, 0, 0, },
{ 206, 534, 842, 1138, 1424, 1686, 1932, 2170, 2396, 2607, 2806, 2991, 3167, 2905, 0, 0, },
{ 192, 554, 862, 1158, 1444, 1706, 1952, 2190, 2416, 2627, 2826, 3011, 3187, 2925, 0, 0, },
{ 179, 545, 907, 1215, 1511, 1797, 2059, 2305, 2543, 2769, 2980, 3179, 3364, 3130, 0, 0, },
{ 167, 565, 927, 1235, 1531, 1817, 2079, 2325, 2563, 2789, 3000, 3199, 3384, 3150, 0, 0, },
{ 157, 570, 936, 1298, 1606, 1902, 2188, 2450, 2696, 2934, 3160, 3371, 3570, 3364, 0, 0, },
{ 148, 577, 975, 1337, 1645, 1941, 2227, 2489, 2735, 2973, 3199, 3410, 3609, 3403, 0, 0, },
{ 138, 587, 1000, 1366, 1728, 2036, 2332, 2618, 2880, 3126, 3364, 3590, 3801, 3627, 0, 0, },
{ 129, 598, 1027, 1425, 1787, 2095, 2391, 2677, 2939, 3185, 3423, 3649, 3860, 3686, 0, 0, },
{ 122, 606, 1055, 1468, 1834, 2196, 2504, 2800, 3086, 3348, 3594, 3832, 4058, 3916, 0, 0, },
{ 115, 626, 1075, 1488, 1854, 2216, 2524, 2820, 3106, 3368, 3614, 3852, 4078, 3936, 0, 0, },
{ 108, 629, 1113, 1562, 1975, 2341, 2703, 3011, 3307, 3593, 3855, 4101, 4339, 4231, 0, 0, },
{ 102, 648, 1132, 1581, 1994, 2360, 2722, 3030, 3326, 3612, 3874, 4120, 4358, 4250, 0, 0, },
{ 96, 660, 1171, 1620, 2033, 2399, 2761, 3069, 3365, 3651, 3913, 4159, 4397, 4289, 0, 0, },
{ 90, 674, 1195, 1679, 2128, 2541, 2907, 3269, 3577, 3873, 4159, 4421, 4667, 4591, 0, 0, },
{ 85, 692, 1213, 1697, 2146, 2559, 2925, 3287, 3595, 3891, 4177, 4439, 4685, 4609, 0, 0, },
{ 80, 699, 1263, 1774, 2223, 2636, 3002, 3364, 3672, 3968, 4254, 4516, 4762, 4686, 0, 0, },
{ 75, 720, 1284, 1795, 2244, 2657, 3023, 3385, 3693, 3989, 4275, 4537, 4783, 4707, 0, 0, },
{ 72, 731, 1315, 1836, 2320, 2769, 3182, 3548, 3910, 4218, 4514, 4800, 5062, 5012, 0, 0, },
{ 67, 752, 1336, 1857, 2341, 2790, 3203, 3569, 3931, 4239, 4535, 4821, 5083, 5033, 0, 0, },
{ 64, 759, 1378, 1942, 2453, 2902, 3315, 3681, 4043, 4351, 4647, 4933, 5195, 5145, 0, 0, },
{ 60, 780, 1399, 1963, 2474, 2923, 3336, 3702, 4064, 4372, 4668, 4954, 5216, 5166, 0, 0, },
{ 57, 795, 1440, 2004, 2515, 2964, 3377, 3743, 4105, 4413, 4709, 4995, 5257, 5207, 0, 0, },
{ 54, 813, 1458, 2022, 2533, 2982, 3395, 3761, 4123, 4431, 4727, 5013, 5275, 5225, 0, 0, },
{ 51, 824, 1509, 2093, 2614, 3098, 3547, 3960, 4326, 4688, 4996, 5292, 5578, 5558, 0, 0, },
{ 48, 843, 1528, 2112, 2633, 3117, 3566, 3979, 4345, 4707, 5015, 5311, 5597, 5577, 0, 0, },
{ 45, 860, 1555, 2174, 2738, 3249, 3698, 4111, 4477, 4839, 5147, 5443, 5729, 5709, 0, 0, },
{ 43, 877, 1572, 2191, 2755, 3266, 3715, 4128, 4494, 4856, 5164, 5460, 5746, 5726, 0, 0, },
{ 41, 895, 1615, 2234, 2798, 3309, 3758, 4171, 4537, 4899, 5207, 5503, 5789, 5769, 0, 0, },
{ 39, 909, 1647, 2292, 2856, 3367, 3816, 4229, 4595, 4957, 5265, 5561, 5847, 5827, 0, 0, },
{ 36, 931, 1669, 2314, 2878, 3389, 3838, 4251, 4617, 4979, 5287, 5583, 5869, 5849, 0, 0, },
{ 35, 947, 1706, 2351, 2915, 3426, 3875, 4288, 4654, 5016, 5324, 5620, 5906, 5886, 0, 0, },
{ 33, 963, 1736, 2421, 3005, 3526, 4010, 4459, 4872, 5238, 5600, 5908, 6204, 6224, 0, 0, },
{ 31, 984, 1757, 2442, 3026, 3547, 4031, 4480, 4893, 5259, 5621, 5929, 6225, 6245, 0, 0, },
{ 30, 996, 1791, 2476, 3060, 3581, 4065, 4514, 4927, 5293, 5655, 5963, 6259, 6279, 0, 0, },
{ 28, 1015, 1810, 2495, 3079, 3600, 4084, 4533, 4946, 5312, 5674, 5982, 6278, 6298, 0, 0, },
{ 26, 1032, 1847, 2542, 3161, 3725, 4236, 4685, 5098, 5464, 5826, 6134, 6430, 6450, 0, 0, },
{ 25, 1051, 1885, 2580, 3199, 3763, 4274, 4723, 5136, 5502, 5864, 6172, 6468, 6488, 0, 0, },
{ 24, 1067, 1901, 2596, 3215, 3779, 4290, 4739, 5152, 5518, 5880, 6188, 6484, 6504, 0, 0, },
{ 23, 1085, 1939, 2659, 3278, 3842, 4353, 4802, 5215, 5581, 5943, 6251, 6547, 6567, 0, 0, },
{ 21, 1106, 1960, 2680, 3299, 3863, 4374, 4823, 5236, 5602, 5964, 6272, 6568, 6588, 0, 0, },
{ 20, 1128, 1982, 2702, 3321, 3885, 4396, 4845, 5258, 5624, 5986, 6294, 6590, 6610, 0, 0, },
{ 19, 1145, 2015, 2753, 3398, 3962, 4473, 4922, 5335, 5701, 6063, 6371, 6667, 6687, 0, 0, },
{ 18, 1156, 2051, 2789, 3434, 3998, 4509, 4958, 5371, 5737, 6099, 6407, 6703, 6723, 0, 0, },
{ 17, 1177, 2072, 2810, 3455, 4019, 4530, 4979, 5392, 5758, 6120, 6428, 6724, 6744, 0, 0, },
{ 16, 1199, 2111, 2870, 3515, 4079, 4590, 5039, 5452, 5818, 6180, 6488, 6784, 6804, 0, 0, },
{ 15, 1215, 2127, 2886, 3531, 4095, 4606, 5055, 5468, 5834, 6196, 6504, 6800, 6820, 0, 0, },
{ 15, 1233, 2145, 2904, 3549, 4113, 4624, 5073, 5486, 5852, 6214, 6522, 6818, 6838, 0, 0, },
{ 14, 1249, 2179, 2952, 3637, 4221, 4742, 5226, 5675, 6088, 6454, 6816, 7124, 7174, 0, 0, },
{ 13, 1270, 2200, 2973, 3658, 4242, 4763, 5247, 5696, 6109, 6475, 6837, 7145, 7195, 0, 0, },
{ 13, 1280, 2233, 3006, 3691, 4275, 4796, 5280, 5729, 6142, 6508, 6870, 7178, 7228, 0, 0, },
{ 12, 1311, 2264, 3037, 3722, 4306, 4827, 5311, 5760, 6173, 6539, 6901, 7209, 7259, 0, 0, },
{ 11, 1325, 2278, 3051, 3736, 4320, 4841, 5325, 5774, 6187, 6553, 6915, 7223, 7273, 0, 0, },
{ 11, 1343, 2309, 3104, 3789, 4373, 4894, 5378, 5827, 6240, 6606, 6968, 7276, 7326, 0, 0, },
{ 10, 1368, 2334, 3129, 3814, 4398, 4919, 5403, 5852, 6265, 6631, 6993, 7301, 7351, 0, 0, },
{ 9, 1388, 2354, 3149, 3834, 4418, 4939, 5423, 5872, 6285, 6651, 7013, 7321, 7371, 0, 0, },
{ 9, 1394, 2381, 3176, 3861, 4445, 4966, 5450, 5899, 6312, 6678, 7040, 7348, 7398, 0, 0, },
{ 9, 1413, 2400, 3195, 3880, 4464, 4985, 5469, 5918, 6331, 6697, 7059, 7367, 7417, 0, 0, },
{ 8, 1437, 2424, 3219, 3904, 4488, 5009, 5493, 5942, 6355, 6721, 7083, 7391, 7441, 0, 0, },
{ 8, 1456, 2462, 3277, 3972, 4591, 5155, 5666, 6115, 6528, 6894, 7256, 7564, 7614, 0, 0, },
{ 7, 1477, 2483, 3298, 3993, 4612, 5176, 5687, 6136, 6549, 6915, 7277, 7585, 7635, 0, 0, },
{ 2, 1930, 3858, 5786, 7714, 9642, 11570, 13498, 15426, 17354, 19282, 21210, 23138, 25064, 0, 0, },
{ 266, 528, 774, 1012, 1238, 1449, 1648, 1833, 2009, 2177, 2335, 2482, 2624, 2251, 0, 0, },
{ 282, 528, 766, 992, 1203, 1402, 1587, 1763, 1931, 2089, 2236, 2378, 2512, 2113, 0, 0, },
{ 296, 534, 760, 971, 1170, 1355, 1531, 1699, 1857, 2004, 2146, 2280, 2407, 1983, 0, 0, },
{ 314, 540, 751, 950, 1135, 1311, 1479, 1637, 1784, 1926, 2060, 2187, 2308, 1859, 0, 0, },
{ 334, 545, 744, 929, 1105, 1273, 1431, 1578, 1720, 1854, 1981, 2102, 2219, 1743, 0, 0, },
{ 353, 552, 737, 913, 1081, 1239, 1386, 1528, 1662, 1789, 1910, 2027, 2135, 1636, 0, 0, },
{ 373, 558, 734, 902, 1060, 1207, 1349, 1483, 1610, 1731, 1848, 1956, 2060, 1537, 0, 0, },
{ 391, 567, 735, 893, 1040, 1182, 1316, 1443, 1564, 1681, 1789, 1893, 1994, 1445, 0, 0, },
{ 410, 578, 736, 883, 1025, 1159, 1286, 1407, 1524, 1632, 1736, 1837, 1929, 1360, 0, 0, },
{ 430, 588, 735, 877, 1011, 1138, 1259, 1376, 1484, 1588, 1689, 1781, 1874, 1279, 0, 0, },
{ 450, 597, 739, 873, 1000, 1121, 1238, 1346, 1450, 1551, 1643, 1736, 1820, 1205, 0, 0, },
{ 468, 610, 744, 871, 992, 1109, 1217, 1321, 1422, 1514, 1607, 1691, 1776, 1136, 0, 0, },
{ 488, 622, 749, 870, 987, 1095, 1199, 1300, 1392, 1485, 1569, 1654, 1734, 1071, 0, 0, },
{ 507, 634, 755, 872, 980, 1084, 1185, 1277, 1370, 1454, 1539, 1619, 1694, 1010, 0, 0, },
{ 526, 647, 764, 872, 976, 1077, 1169, 1262, 1346, 1431, 1511, 1586, 1659, 953, 0, 0, },
{ 545, 662, 770, 874, 975, 1067, 1160, 1244, 1329, 1409, 1484, 1557, 1627, 899, 0, 0, },
{ 566, 674, 778, 879, 971, 1064, 1148, 1233, 1313, 1388, 1461, 1531, 1599, 848, 0, 0, },
{ 584, 688, 789, 881, 974, 1058, 1143, 1223, 1298, 1371, 1441, 1509, 1571, 801, 0, 0, },
{ 603, 704, 796, 889, 973, 1058, 1138, 1213, 1286, 1356, 1424, 1486, 1551, 757, 0, 0, },
{ 624, 716, 809, 893, 978, 1058, 1133, 1206, 1276, 1344, 1406, 1471, 1529, 716, 0, 0, },
{ 641, 734, 818, 903, 983, 1058, 1131, 1201, 1269, 1331, 1396, 1454, 1515, 677, 0, 0, },
{ 662, 746, 831, 911, 986, 1059, 1129, 1197, 1259, 1324, 1382, 1443, 1498, 640, 0, 0, },
{ 679, 764, 844, 919, 992, 1062, 1130, 1192, 1257, 1315, 1376, 1431, 1485, 606, 0, 0, },
{ 700, 780, 855, 928, 998, 1066, 1128, 1193, 1251, 1312, 1367, 1421, 1475, 573, 0, 0, },
{ 720, 795, 868, 938, 1006, 1068, 1133, 1191, 1252, 1307, 1361, 1415, 1461, 543, 0, 0, },
{ 738, 811, 881, 949, 1011, 1076, 1134, 1195, 1250, 1304, 1358, 1404, 1453, 514, 0, 0, },
{ 757, 827, 895, 957, 1022, 1080, 1141, 1196, 1250, 1304, 1350, 1399, 1447, 486, 0, 0, },
{ 776, 844, 906, 971, 1029, 1090, 1145, 1199, 1253, 1299, 1348, 1396, 1443, 460, 0, 0, },
{ 796, 858, 923, 981, 1042, 1097, 1151, 1205, 1251, 1300, 1348, 1395, 1436, 436, 0, 0, },
{ 813, 878, 936, 997, 1052, 1106, 1160, 1206, 1255, 1303, 1350, 1391, 1435, 414, 0, 0, },
{ 835, 893, 954, 1009, 1063, 1117, 1163, 1212, 1260, 1307, 1348, 1392, 1436, 392, 0, 0, },
{ 852, 913, 968, 1022, 1076, 1122, 1171, 1219, 1266, 1307, 1351, 1395, 1438, 371, 0, 0, },
{ 874, 929, 983, 1037, 1083, 1132, 1180, 1227, 1268, 1312, 1356, 1399, 1438, 351, 0, 0, },
{ 893, 947, 1001, 1047, 1096, 1144, 1191, 1232, 1276, 1320, 1363, 1402, 1435, 333, 0, 0, },
{ 912, 966, 1012, 1061, 1109, 1156, 1197, 1241, 1285, 1328, 1367, 1400, 1439, 315, 0, 0, },
{ 933, 979, 1028, 1076, 1123, 1164, 1208, 1252, 1295, 1334, 1367, 1406, 1446, 298, 0, 0, },
{ 948, 997, 1045, 1092, 1133, 1177, 1221, 1264, 1303, 1336, 1375, 1415, 1447, 282, 0, 0, },
{ 967, 1015, 1062, 1103, 1147, 1191, 1234, 1273, 1306, 1345, 1385, 1417, 1450, 267, 0, 0, },
{ 987, 1034, 1075, 1119, 1163, 1206, 1245, 1278, 1317, 1357, 1389, 1422, 1455, 253, 0, 0, },
{ 1008, 1049, 1093, 1137, 1180, 1219, 1252, 1291, 1331, 1363, 1396, 1429, 1464, 240, 0, 0, },
{ 1024, 1068, 1112, 1155, 1194, 1227, 1266, 1306, 1338, 1371, 1404, 1439, 1464, 228, 0, 0, },
{ 1044, 1088, 1131, 1170, 1203, 1242, 1282, 1314, 1347, 1380, 1415, 1440, 1484, 216, 0, 0, },
{ 1065, 1108, 1147, 1180, 1219, 1259, 1291, 1324, 1357, 1392, 1417, 1461, 1487, 204, 0, 0, },
{ 1087, 1126, 1159, 1198, 1238, 1270, 1303, 1336, 1371, 1396, 1440, 1466, 1496, 194, 0, 0, },
{ 1106, 1139, 1178, 1218, 1250, 1283, 1316, 1351, 1376, 1420, 1446, 1476, 1512, 184, 0, 0, },
{ 1120, 1159, 1199, 1231, 1264, 1297, 1332, 1357, 1401, 1427, 1457, 1493, 1523, 174, 0, 0, },
{ 1141, 1181, 1213, 1246, 1279, 1314, 1339, 1383, 1409, 1439, 1475, 1505, 1522, 165, 0, 0, },
{ 1164, 1196, 1229, 1262, 1297, 1322, 1366, 1392, 1422, 1458, 1488, 1505, 1533, 157, 0, 0, },
{ 1180, 1213, 1246, 1281, 1306, 1350, 1376, 1406, 1442, 1472, 1489, 1517, 1550, 149, 0, 0, },
{ 1198, 1231, 1266, 1291, 1335, 1361, 1391, 1427, 1457, 1474, 1502, 1535, 1564, 142, 0, 0, },
{ 1216, 1251, 1276, 1320, 1346, 1376, 1412, 1442, 1459, 1487, 1520, 1549, 1578, 134, 0, 0, },
{ 1237, 1262, 1306, 1332, 1362, 1398, 1428, 1445, 1473, 1506, 1535, 1564, 1571, 127, 0, 0, },
{ 1249, 1293, 1319, 1349, 1385, 1415, 1432, 1460, 1493, 1522, 1551, 1558, 1565, 121, 0, 0, },
{ 1280, 1306, 1336, 1372, 1402, 1419, 1447, 1480, 1509, 1538, 1545, 1552, 1559, 115, 0, 0, },
{ 1294, 1324, 1360, 1390, 1407, 1435, 1468, 1497, 1526, 1533, 1540, 1547, 1554, 110, 0, 0, },
{ 1313, 1349, 1379, 1396, 1424, 1457, 1486, 1515, 1522, 1529, 1536, 1543, 1550, 106, 0, 0, },
{ 1338, 1368, 1385, 1413, 1446, 1475, 1504, 1511, 1518, 1525, 1532, 1539, 1546, 102, 0, 0, },
{ 1358, 1375, 1403, 1436, 1465, 1494, 1501, 1508, 1515, 1522, 1529, 1536, 1543, 99, 0, 0, },
{ 1366, 1394, 1427, 1456, 1485, 1492, 1499, 1506, 1513, 1520, 1527, 1534, 1541, 97, 0, 0, },
{ 1385, 1418, 1447, 1476, 1483, 1490, 1497, 1504, 1511, 1518, 1525, 1532, 1539, 95, 0, 0, },
{ 1409, 1438, 1467, 1474, 1481, 1488, 1495, 1502, 1509, 1516, 1523, 1530, 1537, 93, 0, 0, },
{ 1430, 1459, 1466, 1473, 1480, 1487, 1494, 1501, 1508, 1515, 1522, 1529, 1536, 92, 0, 0, },
{ 1451, 1458, 1465, 1472, 1479, 1486, 1493, 1500, 1507, 1514, 1521, 1528, 1535, 91, 0, 0, },
{ 1928, 1930, 1932, 1934, 1936, 1938, 1940, 1942, 1944, 1946, 1948, 1950, 1952, 26, 0, 0, },
};

#define ENC_B_BITS          (10)
#ifdef CABAC_FAST
#define ENC_M_BITS          (16)
#define ENC_M_FULL          (1 << (ENC_B_BITS + ENC_M_BITS))
#define ENC_M_HALF          (1 << (ENC_B_BITS-1))
#define ENC_M_QUARTER       (1 << (ENC_B_BITS-2))
#else
#define ENC_FULL_RANGE      (1 << (ENC_B_BITS-0))
#define ENC_HALF_RANGE      (1 << (ENC_B_BITS-1))
#define ENC_QUARTER_RANGE   (1 << (ENC_B_BITS-2))
#endif

typedef struct INITIALIZE_VALUES
{
    Ipp8s m;
    Ipp8s n;

} INITIALIZE_VALUES;

// See table 9-12 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_0_10[11] =
{
    {20, -15},
    {2, 54},
    {3, 74},
    {20, -15},
    {2, 54},
    {3, 74},
    {-28, 127},
    {-23, 104},
    {-6, 53},
    {-1, 54},
    {7, 51},
};

// See table 9-17 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_60_69[10] =
{
    {0, 41},
    {0, 63},
    {0, 63},
    {0, 63},
    {-9, 83},
    {4, 86},
    {0, 97},
    {-7, 72},
    {13, 41},
    {3, 62},
};

// See table 9-18 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_70_104_intra[35] =
{
    {0, 11},
    {1, 55},
    {0, 69},
    {-17, 127},
    {-13, 102},
    {0, 82},
    {-7, 74},
    {-21, 107},
    {-27, 127},
    {-31, 127},
    {-24, 127},
    {-18, 95},
    {-27, 127},
    {-21, 114},
    {-30, 127},
    {-17, 123},
    {-12, 115},
    {-16, 122},
    {-11, 115},
    {-12, 63},
    {-2, 68},
    {-15, 84},
    {-13, 104},
    {-3, 70},
    {-8, 93},
    {-10, 90},
    {-30, 127},
    {-1, 74},
    {-6, 97},
    {-7, 91},
    {-20, 127},
    {-4, 56},
    {-5, 82},
    {-7, 76},
    {-22, 125},
};

// See table 9-19 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_105_165_intra[61] =
{
    {-7, 93},
    {-11, 87},
    {-3, 77},
    {-5, 71},
    {-4, 63},
    {-4, 68},
    {-12, 84},
    {-7, 62},
    {-7, 65},
    {8, 61},
    {5, 56},
    {-2, 66},
    {1, 64},
    {0, 61},
    {-2, 78},
    {1, 50},
    {7, 52},
    {10, 35},
    {0, 44},
    {11, 38},
    {1, 45},
    {0, 46},
    {5, 44},
    {31, 17},
    {1, 51},
    {7, 50},
    {28, 19},
    {16, 33},
    {14, 62},
    {-13, 108},
    {-15, 100},
    {-13, 101},
    {-13, 91},
    {-12, 94},
    {-10, 88},
    {-16, 84},
    {-10, 86},
    {-7, 83},
    {-13, 87},
    {-19, 94},
    {1, 70},
    {0, 72},
    {-5, 74},
    {18, 59},
    {-8, 102},
    {-15, 100},
    {0, 95},
    {-4, 75},
    {2, 72},
    {-11, 75},
    {-3, 71},
    {15, 46},
    {-13, 69},
    {0, 62},
    {0, 65},
    {21, 37},
    {-15, 72},
    {9, 57},
    {16, 54},
    {0, 62},
    {12, 72},
};

// See table 9-20 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_166_226_intra[61] =
{
    {24, 0},
    {15, 9},
    {8, 25},
    {13, 18},
    {15, 9},
    {13, 19},
    {10, 37},
    {12, 18},
    {6, 29},
    {20, 33},
    {15, 30},
    {4, 45},
    {1, 58},
    {0, 62},
    {7, 61},
    {12, 38},
    {11, 45},
    {15, 39},
    {11, 42},
    {13, 44},
    {16, 45},
    {12, 41},
    {10, 49},
    {30, 34},
    {18, 42},
    {10, 55},
    {17, 51},
    {17, 46},
    {0, 89},
    {26, -19},
    {22, -17},
    {26, -17},
    {30, -25},
    {28, -20},
    {33, -23},
    {37, -27},
    {33, -23},
    {40, -28},
    {38, -17},
    {33, -11},
    {40, -15},
    {41, -6},
    {38, 1},
    {41, 17},
    {30, -6},
    {27, 3},
    {26, 22},
    {37, -16},
    {35, -4},
    {38, -8},
    {38, -3},
    {37, 3},
    {38, 5},
    {42, 0},
    {35, 16},
    {39, 22},
    {14, 48},
    {27, 37},
    {21, 60},
    {12, 68},
    {2, 97},
};

// See table 9-21 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_227_275_intra[49] =
{
    {-3, 71},
    {-6, 42},
    {-5, 50},
    {-3, 54},
    {-2, 62},
    {0, 58},
    {1, 63},
    {-2, 72},
    {-1, 74},
    {-9, 91},
    {-5, 67},
    {-5, 27},
    {-3, 39},
    {-2, 44},
    {0, 46},
    {-16, 64},
    {-8, 68},
    {-10, 78},
    {-6, 77},
    {-10, 86},
    {-12, 92},
    {-15, 55},
    {-10, 60},
    {-6, 62},
    {-4, 65},
    {-12, 73},
    {-8, 76},
    {-7, 80},
    {-9, 88},
    {-17, 110},
    {-11, 97},
    {-20, 84},
    {-11, 79},
    {-6, 73},
    {-4, 74},
    {-13, 86},
    {-13, 96},
    {-11, 97},
    {-19, 117},
    {-8, 78},
    {-5, 33},
    {-4, 48},
    {-2, 53},
    {-3, 62},
    {-13, 71},
    {-10, 79},
    {-12, 86},
    {-13, 90},
    {-14, 97},
};

// See table 9-22 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_277_337_intra[61] =
{
    {-6, 93},
    {-6, 84},
    {-8, 79},
    {0, 66},
    {-1, 71},
    {0, 62},
    {-2, 60},
    {-2, 59},
    {-5, 75},
    {-3, 62},
    {-4, 58},
    {-9, 66},
    {-1, 79},
    {0, 71},
    {3, 68},
    {10, 44},
    {-7, 62},
    {15, 36},
    {14, 40},
    {16, 27},
    {12, 29},
    {1, 44},
    {20, 36},
    {18, 32},
    {5, 42},
    {1, 48},
    {10, 62},
    {17, 46},
    {9, 64},
    {-12, 104},
    {-11, 97},
    {-16, 96},
    {-7, 88},
    {-8, 85},
    {-7, 85},
    {-9, 85},
    {-13, 88},
    {4, 66},
    {-3, 77},
    {-3, 76},
    {-6, 76},
    {10, 58},
    {-1, 76},
    {-1, 83},
    {-7, 99},
    {-14, 95},
    {2, 95},
    {0, 76},
    {-5, 74},
    {0, 70},
    {-11, 75},
    {1, 68},
    {0, 65},
    {-14, 73},
    {3, 62},
    {4, 62},
    {-1, 68},
    {-13, 75},
    {11, 55},
    {5, 64},
    {12, 70},
};

// See table 9-23 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_338_398_intra[61] =
{
    {15, 6},
    {6, 19},
    {7, 16},
    {12, 14},
    {18, 13},
    {13, 11},
    {13, 15},
    {15, 16},
    {12, 23},
    {13, 23},
    {15, 20},
    {14, 26},
    {14, 44},
    {17, 40},
    {17, 47},
    {24, 17},
    {21, 21},
    {25, 22},
    {31, 27},
    {22, 29},
    {19, 35},
    {14, 50},
    {10, 57},
    {7, 63},
    {-2, 77},
    {-4, 82},
    {-3, 94},
    {9, 69},
    {-12, 109},
    {36, -35},
    {36, -34},
    {32, -26},
    {37, -30},
    {44, -32},
    {34, -18},
    {34, -15},
    {40, -15},
    {33, -7},
    {35, -5},
    {33, 0},
    {38, 2},
    {33, 13},
    {23, 35},
    {13, 58},
    {29, -3},
    {26, 0},
    {22, 30},
    {31, -7},
    {35, -15},
    {34, -3},
    {34, 3},
    {36, -1},
    {34, 5},
    {32, 11},
    {35, 5},
    {34, 12},
    {39, 11},
    {30, 29},
    {34, 26},
    {29, 39},
    {19, 66},
};
INITIALIZE_VALUES M_and_N_for_ctxIdx_399_401_intra[3] =
{
    {31,21},
    {31,31},
    {25,50},
};

INITIALIZE_VALUES M_and_N_for_ctxIdx_402_459_intra[58] =
{
    {-17,120},
    {-20,112},
    {-18,114},
    {-11, 85},
    {-15, 92},
    {-14, 89},
    {-26, 71},
    {-15, 81},
    {-14, 80},
    {  0, 68},
    {-14, 70},
    {-24, 56},
    {-23, 68},
    {-24, 50},
    {-11, 74},
    { 23,-13},
    { 26,-13},
    { 40,-15},
    { 49,-14},
    { 44,  3},
    { 45,  6},
    { 44, 34},
    { 33, 54},
    { 19, 82},
    { -3, 75},
    { -1, 23},
    {  1, 34},
    {  1, 43},
    {  0, 54},
    { -2, 55},
    {  0, 61},
    {  1, 64},
    {  0, 68},
    { -9, 92},
    {-14,106},
    {-13, 97},
    {-15, 90},
    {-12, 90},
    {-18, 88},
    {-10, 73},
    { -9, 79},
    {-14, 86},
    {-10, 73},
    {-10, 70},
    {-10, 69},
    { -5, 66},
    { -9, 64},
    { -5, 58},
    {  2, 59},
    { 21,-10},
    { 24,-11},
    { 28, -8},
    { 28, -1},
    { 29,  3},
    { 29,  9},
    { 35, 20},
    { 29, 36},
    { 14, 67},
};

// See table 9-13 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_11_23[13][3] =
{
    {{23, 33}, {22, 25}, {29, 16}},
    {{23, 2}, {34, 0}, {25, 0}},
    {{21, 0}, {16, 0}, {14, 0}},
    {{1, 9}, {-2, 9}, {-10, 51}},
    {{0, 49}, {4, 41}, {-3, 62}},
    {{-37, 118}, {-29, 118}, {-27, 99}},
    {{5, 57}, {2, 65}, {26, 16}},
    {{-13, 78}, {-6, 71}, {-4, 85}},
    {{-11, 65}, {-13, 79}, {-24, 102}},
    {{1, 62}, {5, 52}, {5, 57}},
    {{12, 49}, {9, 50}, {6, 57}},
    {{-4, 73}, {-3, 70}, {-17, 73}},
    {{17, 50}, {10, 54}, {14, 57}},
};

// See table 9-14 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_24_39[16][3] =
{
    {{18, 64}, {26, 34}, {20, 40}},
    {{9, 43}, {19, 22}, {20, 10}},
    {{29, 0}, {40, 0}, {29, 0}},
    {{26, 67}, {57, 2}, {54, 0}},
    {{16, 90}, {41, 36}, {37, 42}},
    {{9, 104}, {26, 69}, {12, 97}},
    {{-46, 127}, {-45, 127}, {-32, 127}},
    {{-20, 104}, {-15, 101}, {-22, 117}},
    {{1, 67}, {-4, 76}, {-2, 74}},
    {{-13, 78}, {-6, 71}, {-4, 85}},
    {{-11, 65}, {-13, 79}, {-24, 102}},
    {{1, 62}, {5, 52}, {5, 57}},
    {{-6, 86}, {6, 69}, {-6, 93}},
    {{-17, 95}, {-13, 90}, {-14, 88}},
    {{-6, 61}, {0, 52}, {-6, 44}},
    {{9, 45}, {8, 43}, {4, 55}},
};

// See table 9-15 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_40_53[14][3] =
{
    {{-3, 69}, {-2, 69}, {-11, 89}},
    {{-6, 81}, {-5, 82}, {-15, 103}},
    {{-11, 96}, {-10, 96}, {-21, 116}},
    {{6, 55}, {2, 59}, {19, 57}},
    {{7, 67}, {2, 75}, {20, 58}},
    {{-5, 86}, {-3, 87}, {4, 84}},
    {{2, 88}, {-3, 100}, {6, 96}},
    {{0, 58}, {1, 56}, {1, 63}},
    {{-3, 76}, {-3, 74}, {-5, 85}},
    {{-10, 94}, {-6, 85}, {-13, 106}},
    {{5, 54}, {0, 59}, {5, 63}},
    {{4, 69}, {-3, 81}, {6, 75}},
    {{-3, 81}, {-7, 86}, {-3, 90}},
    {{0, 88}, {-5, 95}, {-1, 101}},
};

// See table 9-16 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_54_59[6][3] =
{
    {{-7, 67}, {-1, 66}, {3, 55}},
    {{-5, 74}, {-1, 77}, {-4, 79}},
    {{-4, 74}, {1, 70}, {-2, 75}},
    {{-5, 80}, {-2, 86}, {-12, 97}},
    {{-7, 72}, {-5, 72}, {-7, 50}},
    {{1, 58}, {0, 61}, {1, 60}},
};

// See table 9-18 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_70_104_inter[35][3] =
{
    {{0, 45}, {13, 15}, {7, 34}},
    {{-4, 78}, {7, 51}, {-9, 88}},
    {{-3, 96}, {2, 80}, {-20, 127}},
    {{-27, 126}, {-39, 127}, {-36, 127}},
    {{-28, 98}, {-18, 91}, {-17, 91}},
    {{-25, 101}, {-17, 96}, {-14, 95}},
    {{-23, 67}, {-26, 81}, {-25, 84}},
    {{-28, 82}, {-35, 98}, {-25, 86}},
    {{-20, 94}, {-24, 102}, {-12, 89}},
    {{-16, 83}, {-23, 97}, {-17, 91}},
    {{-22, 110}, {-27, 119}, {-31, 127}},
    {{-21, 91}, {-24, 99}, {-14, 76}},
    {{-18, 102}, {-21, 110}, {-18, 103}},
    {{-13, 93}, {-18, 102}, {-13, 90}},
    {{-29, 127}, {-36, 127}, {-37, 127}},
    {{-7, 92}, {0, 80}, {11, 80}},
    {{-5, 89}, {-5, 89}, {5, 76}},
    {{-7, 96}, {-7, 94}, {2, 84}},
    {{-13, 108}, {-4, 92}, {5, 78}},
    {{-3, 46}, {0, 39}, {-6, 55}},
    {{-1, 65}, {0, 65}, {4, 61}},
    {{-1, 57}, {-15, 84}, {-14, 83}},
    {{-9, 93}, {-35, 127}, {-37, 127}},
    {{-3, 74}, {-2, 73}, {-5, 79}},
    {{-9, 92}, {-12, 104}, {-11, 104}},
    {{-8, 87}, {-9, 91}, {-11, 91}},
    {{-23, 126}, {-31, 127}, {-30, 127}},
    {{5, 54}, {3, 55}, {0, 65}},
    {{6, 60}, {7, 56}, {-2, 79}},
    {{6, 59}, {7, 55}, {0, 72}},
    {{6, 69}, {8, 61}, {-4, 92}},
    {{-1, 48}, {-3, 53}, {-6, 56}},
    {{0, 68}, {0, 68}, {3, 68}},
    {{-4, 69}, {-7, 74}, {-8, 71}},
    {{-8, 88}, {-9, 88}, {-13, 98}},
};

// See table 9-19 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_105_165_inter[61][3] =
{
    {{-2, 85}, {-13, 103}, {-4, 86}},
    {{-6, 78}, {-13, 91}, {-12, 88}},
    {{-1, 75}, {-9, 89}, {-5, 82}},
    {{-7, 77}, {-14, 92}, {-3, 72}},
    {{2, 54}, {-8, 76}, {-4, 67}},
    {{5, 50}, {-12, 87}, {-8, 72}},
    {{-3, 68}, {-23, 110}, {-16, 89}},
    {{1, 50}, {-24, 105}, {-9, 69}},
    {{6, 42}, {-10, 78}, {-1, 59}},
    {{-4, 81}, {-20, 112}, {5, 66}},
    {{1, 63}, {-17, 99}, {4, 57}},
    {{-4, 70}, {-78, 127}, {-4, 71}},
    {{0, 67}, {-70, 127}, {-2, 71}},
    {{2, 57}, {-50, 127}, {2, 58}},
    {{-2, 76}, {-46, 127}, {-1, 74}},
    {{11, 35}, {-4, 66}, {-4, 44}},
    {{4, 64}, {-5, 78}, {-1, 69}},
    {{1, 61}, {-4, 71}, {0, 62}},
    {{11, 35}, {-8, 72}, {-7, 51}},
    {{18, 25}, {2, 59}, {-4, 47}},
    {{12, 24}, {-1, 55}, {-6, 42}},
    {{13, 29}, {-7, 70}, {-3, 41}},
    {{13, 36}, {-6, 75}, {-6, 53}},
    {{-10, 93}, {-8, 89}, {8, 76}},
    {{-7, 73}, {-34, 119}, {-9, 78}},
    {{-2, 73}, {-3, 75}, {-11, 83}},
    {{13, 46}, {32, 20}, {9, 52}},
    {{9, 49}, {30, 22}, {0, 67}},
    {{-7, 100}, {-44, 127}, {-5, 90}},
    {{9, 53}, {0, 54}, {1, 67}},
    {{2, 53}, {-5, 61}, {-15, 72}},
    {{5, 53}, {0, 58}, {-5, 75}},
    {{-2, 61}, {-1, 60}, {-8, 80}},
    {{0, 56}, {-3, 61}, {-21, 83}},
    {{0, 56}, {-8, 67}, {-21, 64}},
    {{-13, 63}, {-25, 84}, {-13, 31}},
    {{-5, 60}, {-14, 74}, {-25, 64}},
    {{-1, 62}, {-5, 65}, {-29, 94}},
    {{4, 57}, {5, 52}, {9, 75}},
    {{-6, 69}, {2, 57}, {17, 63}},
    {{4, 57}, {0, 61}, {-8, 74}},
    {{14, 39}, {-9, 69}, {-5, 35}},
    {{4, 51}, {-11, 70}, {-2, 27}},
    {{13, 68}, {18, 55}, {13, 91}},
    {{3, 64}, {-4, 71}, {3, 65}},
    {{1, 61}, {0, 58}, {-7, 69}},
    {{9, 63}, {7, 61}, {8, 77}},
    {{7, 50}, {9, 41}, {-10, 66}},
    {{16, 39}, {18, 25}, {3, 62}},
    {{5, 44}, {9, 32}, {-3, 68}},
    {{4, 52}, {5, 43}, {-20, 81}},
    {{11, 48}, {9, 47}, {0, 30}},
    {{-5, 60}, {0, 44}, {1, 7}},
    {{-1, 59}, {0, 51}, {-3, 23}},
    {{0, 59}, {2, 46},{-21, 74}},
    {{22, 33}, {19, 38}, {16, 66}},
    {{5, 44}, {-4, 66}, {-23, 124}},
    {{14, 43}, {15, 38}, {17, 37}},
    {{-1, 78}, {12, 42}, {44, -18}},
    {{0, 60}, {9, 34}, {50, -34}},
    {{9, 69}, {0, 89}, {-22, 127}},
};

// See table 9-20 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_166_226_inter[61][3] =
{
    {{11, 28}, {4, 45}, {4, 39}},
    {{2, 40}, {10, 28}, {0, 42}},
    {{3, 44}, {10, 31}, {7, 34}},
    {{0, 49}, {33, -11}, {11, 29}},
    {{0, 46}, {52, -43}, {8, 31}},
    {{2, 44}, {18, 15}, {6, 37}},
    {{2, 51}, {28, 0}, {7, 42}},
    {{0, 47}, {35, -22}, {3, 40}},
    {{4, 39}, {38, -25}, {8, 33}},
    {{2, 62}, {34, 0}, {13, 43}},
    {{6, 46}, {39, -18}, {13, 36}},
    {{0, 54}, {32, -12}, {4, 47}},
    {{3, 54}, {102, -94}, {3, 55}},
    {{2, 58}, {0, 0}, {2, 58}},
    {{4, 63}, {56, -15}, {6, 60}},
    {{6, 51}, {33, -4}, {8, 44}},
    {{6, 57}, {29, 10}, {11, 44}},
    {{7, 53}, {37, -5}, {14, 42}},
    {{6, 52}, {51, -29}, {7, 48}},
    {{6, 55}, {39, -9}, {4, 56}},
    {{11, 45}, {52, -34}, {4, 52}},
    {{14, 36}, {69, -58}, {13, 37}},
    {{8, 53}, {67, -63}, {9, 49}},
    {{-1, 82}, {44, -5}, {19, 58}},
    {{7, 55}, {32, 7}, {10, 48}},
    {{-3, 78}, {55, -29}, {12, 45}},
    {{15, 46}, {32, 1}, {0, 69}},
    {{22, 31}, {0, 0}, {20, 33}},
    {{-1, 84}, {27, 36}, {8, 63}},
    {{25, 7}, {33, -25}, {35, -18}},
    {{30, -7}, {34, -30}, {33, -25}},
    {{28, 3}, {36, -28}, {28, -3}},
    {{28, 4}, {38, -28}, {24, 10}},
    {{32, 0}, {38, -27}, {27, 0}},
    {{34, -1}, {34, -18}, {34, -14}},
    {{30, 6}, {35, -16}, {52, -44}},
    {{30, 6}, {34, -14}, {39, -24}},
    {{32, 9}, {32, -8}, {19, 17}},
    {{31, 19}, {37, -6}, {31, 25}},
    {{26, 27}, {35, 0}, {36, 29}},
    {{26, 30}, {30, 10}, {24, 33}},
    {{37, 20}, {28, 18}, {34, 15}},
    {{28, 34}, {26, 25}, {30, 20}},
    {{17, 70}, {29, 41}, {22, 73}},
    {{1, 67}, {0, 75}, {20, 34}},
    {{5, 59}, {2, 72}, {19, 31}},
    {{9, 67}, {8, 77}, {27, 44}},
    {{16, 30}, {14, 35}, {19, 16}},
    {{18, 32}, {18, 31}, {15, 36}},
    {{18, 35}, {17, 35}, {15, 36}},
    {{22, 29}, {21, 30}, {21, 28}},
    {{24, 31}, {17, 45}, {25, 21}},
    {{23, 38}, {20, 42}, {30, 20}},
    {{18, 43}, {18, 45}, {31, 12}},
    {{20, 41}, {27, 26}, {27, 16}},
    {{11, 63}, {16, 54}, {24, 42}},
    {{9, 59}, {7, 66}, {0, 93}},
    {{9, 64}, {16, 56}, {14, 56}},
    {{-1, 94}, {11, 73}, {15, 57}},
    {{-2, 89}, {10, 67}, {26, 38}},
    {{-9, 108}, {-10, 116}, {-24, 127}},
};

// See table 9-21 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_227_275_inter[49][3] =
{
    {{-6, 76}, {-23, 112}, {-24, 115}},
    {{-2, 44}, {-15, 71}, {-22, 82}},
    {{0, 45}, {-7, 61}, {-9, 62}},
    {{0, 52}, {0, 53}, {0, 53}},
    {{-3, 64}, {-5, 66}, {0, 59}},
    {{-2, 59}, {-11, 77}, {-14, 85}},
    {{-4, 70}, {-9, 80}, {-13, 89}},
    {{-4, 75}, {-9, 84}, {-13, 94}},
    {{-8, 82}, {-10, 87}, {-11, 92}},
    {{-17, 102}, {-34, 127}, {-29, 127}},
    {{-9, 77}, {-21, 101}, {-21, 100}},
    {{3, 24}, {-3, 39}, {-14, 57}},
    {{0, 42}, {-5, 53}, {-12, 67}},
    {{0, 48}, {-7, 61}, {-11, 71}},
    {{0, 55}, {-11, 75}, {-10, 77}},
    {{-6, 59}, {-15, 77}, {-21, 85}},
    {{-7, 71}, {-17, 91}, {-16, 88}},
    {{-12, 83}, {-25, 107}, {-23, 104}},
    {{-11, 87}, {-25, 111}, {-15, 98}},
    {{-30, 119}, {-28, 122}, {-37, 127}},
    {{1, 58}, {-11, 76}, {-10, 82}},
    {{-3, 29}, {-10, 44}, {-8, 48}},
    {{-1, 36}, {-10, 52}, {-8, 61}},
    {{1, 38}, {-10, 57}, {-8, 66}},
    {{2, 43}, {-9, 58}, {-7, 70}},
    {{-6, 55}, {-16, 72}, {-14, 75}},
    {{0, 58}, {-7, 69}, {-10, 79}},
    {{0, 64}, {-4, 69}, {-9, 83}},
    {{-3, 74}, {-5, 74}, {-12, 92}},
    {{-10, 90}, {-9, 86}, {-18, 108}},
    {{0, 70}, {2, 66}, {-4, 79}},
    {{-4, 29}, {-9, 34}, {-22, 69}},
    {{5, 31}, {1, 32}, {-16, 75}},
    {{7, 42}, {11, 31}, {-2, 58}},
    {{1, 59}, {5, 52}, {1, 58}},
    {{-2, 58}, {-2, 55}, {-13, 78}},
    {{-3, 72}, {-2, 67}, {-9, 83}},
    {{-3, 81}, {0, 73}, {-4, 81}},
    {{-11, 97}, {-8, 89}, {-13, 99}},
    {{0, 58}, {3, 52}, {-13, 81}},
    {{8, 5}, {7, 4}, {-6, 38}},
    {{10, 14}, {10, 8}, {-13, 62}},
    {{14, 18}, {17, 8}, {-6, 58}},
    {{13, 27}, {16, 19}, {-2, 59}},
    {{2, 40}, {3, 37}, {-16, 73}},
    {{0, 58}, {-1, 61}, {-10, 76}},
    {{-3, 70}, {-5, 73}, {-13, 86}},
    {{-6, 79}, {-1, 70}, {-9, 83}},
    {{-8, 85}, {-4, 78}, {-10, 87}},
};

// See table 9-22 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_277_337_inter[61][3] =
{
    {{-13, 106}, {-21, 126}, {-22, 127}},
    {{-16, 106}, {-23, 124}, {-25, 127}},
    {{-10, 87}, {-20, 110}, {-25, 120}},
    {{-21, 114}, {-26, 126}, {-27, 127}},
    {{-18, 110}, {-25, 124}, {-19, 114}},
    {{-14, 98}, {-17, 105}, {-23, 117}},
    {{-22, 110}, {-27, 121}, {-25, 118}},
    {{-21, 106}, {-27, 117}, {-26, 117}},
    {{-18, 103}, {-17, 102}, {-24, 113}},
    {{-21, 107}, {-26, 117}, {-28, 118}},
    {{-23, 108}, {-27, 116}, {-31, 120}},
    {{-26, 112}, {-33, 122}, {-37, 124}},
    {{-10, 96}, {-10, 95}, {-10, 94}},
    {{-12, 95}, {-14, 100}, {-15, 102}},
    {{-5, 91}, {-8, 95}, {-10, 99}},
    {{-9, 93}, {-17, 111}, {-13, 106}},
    {{-22, 94}, {-28, 114}, {-50, 127}},
    {{-5, 86}, {-6, 89}, {-5, 92}},
    {{9, 67}, {-2, 80}, {17, 57}},
    {{-4, 80}, {-4, 82}, {-5, 86}},
    {{-10, 85}, {-9, 85}, {-13, 94}},
    {{-1, 70}, {-8, 81}, {-12, 91}},
    {{7, 60}, {-1, 72}, {-2, 77}},
    {{9, 58}, {5, 64}, {0, 71}},
    {{5, 61}, {1, 67}, {-1, 73}},
    {{12, 50}, {9, 56}, {4, 64}},
    {{15, 50}, {0, 69}, {-7, 81}},
    {{18, 49}, {1, 69}, {5, 64}},
    {{17, 54}, {7, 69}, {15, 57}},
    {{10, 41}, {-7, 69}, {1, 67}},
    {{7, 46}, {-6, 67}, {0, 68}},
    {{-1, 51}, {-16, 77}, {-10, 67}},
    {{7, 49}, {-2, 64}, {1, 68}},
    {{8, 52}, {2, 61}, {0, 77}},
    {{9, 41}, {-6, 67}, {2, 64}},
    {{6, 47}, {-3, 64}, {0, 68}},
    {{2, 55}, {2, 57}, {-5, 78}},
    {{13, 41}, {-3, 65}, {7, 55}},
    {{10, 44}, {-3, 66}, {5, 59}},
    {{6, 50}, {0, 62}, {2, 65}},
    {{5, 53}, {9, 51}, {14, 54}},
    {{13, 49}, {-1, 66}, {15, 44}},
    {{4, 63}, {-2, 71}, {5, 60}},
    {{6, 64}, {-2, 75}, {2, 70}},
    {{-2, 69}, {-1, 70}, {-2, 76}},
    {{-2, 59}, {-9, 72}, {-18, 86}},
    {{6, 70}, {14, 60}, {12, 70}},
    {{10, 44}, {16, 37}, {5, 64}},
    {{9, 31}, {0, 47}, {-12, 70}},
    {{12, 43}, {18, 35}, {11, 55}},
    {{3, 53}, {11, 37}, {5, 56}},
    {{14, 34}, {12, 41}, {0, 69}},
    {{10, 38}, {10, 41}, {2, 65}},
    {{-3, 52}, {2, 48}, {-6, 74}},
    {{13, 40}, {12, 41}, {5, 54}},
    {{17, 32}, {13, 41}, {7, 54}},
    {{7, 44}, {0, 59}, {-6, 76}},
    {{7, 38}, {3, 50}, {-11, 82}},
    {{13, 50}, {19, 40}, {-2, 77}},
    {{10, 57}, {3, 66}, {-2, 77}},
    {{26, 43}, {18, 50}, {25, 42}},
};

// See table 9-23 of H.264 standard
INITIALIZE_VALUES M_and_N_for_ctxIdx_338_398_inter[61][3] =
{
    {{14, 11}, {19, -6}, {17, -13}},
    {{11, 14}, {18, -6}, {16, -9}},
    {{9, 11}, {14, 0}, {17, -12}},
    {{18, 11}, {26, -12}, {27, -21}},
    {{21, 9}, {31, -16}, {37, -30}},
    {{23, -2}, {33, -25}, {41, -40}},
    {{32, -15}, {33, -22}, {42, -41}},
    {{32, -15}, {37, -28}, {48, -47}},
    {{34, -21}, {39, -30}, {39, -32}},
    {{39, -23}, {42, -30}, {46, -40}},
    {{42, -33}, {47, -42}, {52, -51}},
    {{41, -31}, {45, -36}, {46, -41}},
    {{46, -28}, {49, -34}, {52, -39}},
    {{38, -12}, {41, -17}, {43, -19}},
    {{21, 29}, {32, 9}, {32, 11}},
    {{45, -24}, {69, -71}, {61, -55}},
    {{53, -45}, {63, -63}, {56, -46}},
    {{48, -26}, {66, -64}, {62, -50}},
    {{65, -43}, {77, -74}, {81, -67}},
    {{43, -19}, {54, -39}, {45, -20}},
    {{39, -10}, {52, -35}, {35, -2}},
    {{30, 9}, {41, -10}, {28, 15}},
    {{18, 26}, {36, 0}, {34, 1}},
    {{20, 27}, {40, -1}, {39, 1}},
    {{0, 57}, {30, 14}, {30, 17}},
    {{-14, 82}, {28, 26}, {20, 38}},
    {{-5, 75}, {23, 37}, {18, 45}},
    {{-19, 97}, {12, 55}, {15, 54}},
    {{-35, 125}, {11, 65}, {0, 79}},
    {{27, 0}, {37, -33}, {36, -16}},
    {{28, 0}, {39, -36}, {37, -14}},
    {{31, -4}, {40, -37}, {37, -17}},
    {{27, 6}, {38, -30}, {32, 1}},
    {{34, 8}, {46, -33}, {34, 15}},
    {{30, 10}, {42, -30}, {29, 15}},
    {{24, 22}, {40, -24}, {24, 25}},
    {{33, 19}, {49, -29}, {34, 22}},
    {{22, 32}, {38, -12}, {31, 16}},
    {{26, 31}, {40, -10}, {35, 18}},
    {{21, 41}, {38, -3}, {31, 28}},
    {{26, 44}, {46, -5}, {33, 41}},
    {{23, 47}, {31, 20}, {36, 28}},
    {{16, 65}, {29, 30}, {27, 47}},
    {{14, 71}, {25, 44}, {21, 62}},
    {{8, 60}, {12, 48}, {18, 31}},
    {{6, 63}, {11, 49}, {19, 26}},
    {{17, 65}, {26, 45}, {36, 24}},
    {{21, 24}, {22, 22}, {24, 23}},
    {{23, 20}, {23, 22}, {27, 16}},
    {{26, 23}, {27, 21}, {24, 30}},
    {{27, 32}, {33, 20}, {31, 29}},
    {{28, 23}, {26, 28}, {22, 41}},
    {{28, 24}, {30, 24}, {22, 42}},
    {{23, 40}, {27, 34}, {16, 60}},
    {{24, 32}, {18, 42}, {15, 52}},
    {{28, 29}, {25, 39}, {14, 60}},
    {{23, 42}, {18, 50}, {3, 78}},
    {{19, 57}, {12, 70}, {-16, 123}},
    {{22, 53}, {21, 54}, {21, 53}},
    {{22, 61}, {14, 71}, {22, 56}},
    {{11, 86}, {11, 83}, {25, 61}},
};

INITIALIZE_VALUES M_and_N_for_ctxIdx_399_401_inter[3][3] =
{
    {{12, 40}, {25, 32}, {21, 33}},
    {{11, 51}, {21, 49}, {19, 50}},
    {{14, 59}, {21, 54}, {17, 61}},
};

INITIALIZE_VALUES M_and_N_for_ctxIdx_402_459_inter[58][3] =
{
    {{-4, 79}, {-5, 85}, {-3, 78}},
    {{-7, 71}, {-6, 81}, {-8, 74}},
    {{-5, 69}, {-10,77}, {-9, 72}},
    {{-9, 70}, {-7, 81}, {-10,72}},
    {{-8 ,66}, {-17,80}, {-18,75}},
    {{-10,68}, {-18,73}, {-12,71}},
    {{-19,73}, {-4, 74}, {-11,63}},
    {{-12,69}, {-10,83}, {-5, 70}},
    {{-16,70}, {-9, 71}, {-17,75}},
    {{-15,67}, {-9, 67}, {-14,72}},
    {{-20,62}, {-1, 61}, {-16,67}},
    {{-19,70}, {-8, 66}, {-8, 53}},
    {{-16,66}, {-14,66}, {-14,59}},
    {{-22,65}, {0,  59}, {-9, 52}},
    {{-20,63}, {2,  59}, {-11,68}},
    {{9,  -2}, {17,-10}, {9,  -2}},
    {{26, -9}, {32,-13}, {30,-10}},
    {{33, -9}, {42, -9}, {31, -4}},
    {{39, -7}, {49, -5}, {33, -1}},
    {{41, -2}, {53,  0}, {33,  7}},
    {{45,  3}, {64,  3}, {31, 12}},
    {{49,  9}, {68, 10}, {37, 23}},
    {{45, 27}, {66, 27}, {31, 38}},
    {{36, 59}, {47, 57}, {20, 64}},
    {{-6, 66}, {-5, 71}, {-9, 71}},
    {{-7, 35}, {0,  24}, {-7, 37}},
    {{-7, 42}, {-1, 36}, {-8, 44}},
    {{-8, 45}, {-2, 42}, {-11,49}},
    {{-5, 48}, {-2, 52}, {-10,56}},
    {{-12,56}, {-9, 57}, {-12,59}},
    {{-6, 60}, {-6, 63}, {-8, 63}},
    {{-5, 62}, {-4, 65}, {-9, 67}},
    {{-8, 66}, {-4, 67}, {-6, 68}},
    {{-8, 76}, {-7, 82}, {-10,79}},
    {{-5, 85}, {-3, 81}, {-3, 78}},
    {{-6, 81}, {-3, 76}, {-8, 74}},
    {{-10,77}, {-7, 72}, {-9, 72}},
    {{-7, 81}, {-6, 78}, {-10,72}},
    {{-17,80}, {-12,72}, {-18,75}},
    {{-18,73}, {-14,68}, {-12,71}},
    {{-4, 74}, {-3, 70}, {-11,63}},
    {{-10,83}, {-6, 76}, {-5, 70}},
    {{-9, 71}, {-5, 66}, {-17,75}},
    {{-9, 67}, {-5, 62}, {-14,72}},
    {{-1, 61}, {0,  57}, {-16,67}},
    {{-8, 66}, {-4, 61}, {-8, 53}},
    {{-14,66}, {-9, 60}, {-14,59}},
    {{0,  59}, {1,  54}, {-9, 52}},
    {{2,  59}, {2,  58}, {-11,68}},
    {{21,-13}, {17,-10}, {9,  -2}},
    {{33,-14}, {32,-13}, {30,-10}},
    {{39, -7}, {42, -9}, {31, -4}},
    {{46, -2}, {49, -5}, {33, -1}},
    {{51,  2}, {53,  0}, {33,  7}},
    {{60,  6}, {64,  3}, {31, 12}},
    {{61, 17}, {68, 10}, {37, 23}},
    {{55, 34}, {66, 27}, {31, 38}},
    {{42, 62}, {47, 57}, {20, 64}},
};

#ifdef STORE_CABAC_BITS
    FILE *cabac_bits;
    Ipp32s sym_cnt;
#endif

// ---------------------------------------------------------------------------

/************************* cabac part **************************/

#define Clip3(Min, Max, Value) ((Value) < (Min)) ? (Min) : ((Value) > (Max)) ? (Max) : (Value)

void InitializeContext(
    CABAC_CONTEXT *lpContext,
    Ipp8s m,
    Ipp8s n,
    Ipp32s SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
    ,Ipp32s ctxIdx
#endif
#endif
)
{
    Ipp8u preCtxState;
    preCtxState = (Ipp8u)(Clip3(1, 126, ((m * SliceQPy) >> 4) + n));
    if (preCtxState <= 63){
        *lpContext = 63 - preCtxState; //MPS = 1
    }else{
        *lpContext = (preCtxState - 64)|(1<<6); //MPS = 1
    }
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
    if (cabac_bits == NULL)
        cabac_bits = fopen(__CABAC_FILE__, "w+t");
    if (cabac_bits)
        fprintf(cabac_bits, "ctx_ini %d %d %d\n", ctxIdx, lpContext->pStateIdx, lpContext->valMPS);
#endif
#endif

} //void InitializeContext(CABAC_CONTEXT *lpContext, Ipp32s m, Ipp32s n, Ipp32s SliceQPy)

void H264BsBase_CopyContextCABAC_Chroma(
    H264BsBase* state,
    H264BsBase* bstrm,
    int isFrame)
{
    if( isFrame ){
        memcpy( &state->context_array[105+44], &bstrm->context_array[105+44], 17*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[166+44], &bstrm->context_array[166+44], 17*sizeof(CABAC_CONTEXT));
    }else{
        memcpy( &state->context_array[105+172+44], &bstrm->context_array[105+172+44], 17*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[166+172+44], &bstrm->context_array[166+172+44], 17*sizeof(CABAC_CONTEXT));
    }
    memcpy( &state->context_array[227+30], &bstrm->context_array[227+30], 19*sizeof(CABAC_CONTEXT));
    //Coded block flag
    memcpy( &state->context_array[85+12], &bstrm->context_array[85+12], 8*sizeof(CABAC_CONTEXT));
    //Chroma pred mode
    state->context_array[64] = bstrm->context_array[64];
    state->context_array[65] = bstrm->context_array[65];
    state->context_array[66] = bstrm->context_array[66];
    state->context_array[67] = bstrm->context_array[67];

//    m_lcodIRange = bstrm->m_lcodIRange;
//    m_lcodIRange = 256;
//    m_bitOffset = ;
}

// ---------------------------------------------------------------------------

void H264BsBase_CopyContextCABAC_I4x4(
    H264BsBase* state,
    H264BsBase* bstrm,
    Ipp32s isFrame)
{
    if( isFrame ){
        memcpy(&state->context_array[105+29], &bstrm->context_array[105+29], 15*sizeof(CABAC_CONTEXT));
        memcpy(&state->context_array[166+29], &bstrm->context_array[166+29], 15*sizeof(CABAC_CONTEXT));
    }else{
        memcpy(&state->context_array[105+172+29], &bstrm->context_array[105+172+29], 15*sizeof(CABAC_CONTEXT));
        memcpy(&state->context_array[166+172+29], &bstrm->context_array[166+172+29], 15*sizeof(CABAC_CONTEXT));
    }
    memcpy(&state->context_array[227+20], &bstrm->context_array[227+20], 10*sizeof(CABAC_CONTEXT));
    //Coded block flag
    memcpy(&state->context_array[85+8], &bstrm->context_array[85+8], 4*sizeof(CABAC_CONTEXT));
    //Intra pred & pred mode
    state->context_array[68] = bstrm->context_array[68];
    state->context_array[69] = bstrm->context_array[69];

//    m_lcodIRange = bstrm->m_lcodIRange;
}

// ---------------------------------------------------------------------------

void H264BsBase_CopyContextCABAC_I8x8(
    H264BsBase* state,
    H264BsBase* bstrm,
    Ipp32s isFrame)
{
    if( isFrame )
        memcpy( &state->context_array[402], &bstrm->context_array[402], 24*sizeof(CABAC_CONTEXT));
    else
        memcpy( &state->context_array[436], &bstrm->context_array[436], 24*sizeof(CABAC_CONTEXT));
    memcpy( &state->context_array[426], &bstrm->context_array[426], 10*sizeof(CABAC_CONTEXT));
    //Intra pred & pred mode
    state->context_array[68] = bstrm->context_array[68];
    state->context_array[69] = bstrm->context_array[69];

//    m_lcodIRange = bstrm->m_lcodIRange;
}

// ---------------------------------------------------------------------------

void H264BsBase_CopyContextCABAC_I16x16(
    H264BsBase* state,
    H264BsBase* bstrm,
    Ipp32s isFrame)
{
    memcpy( &state->context_array[0], &bstrm->context_array[0], 93*sizeof(CABAC_CONTEXT));
    memcpy( &state->context_array[227], &bstrm->context_array[227], 20*sizeof(CABAC_CONTEXT));
    if( isFrame ){
        memcpy( &state->context_array[105], &bstrm->context_array[105], 29*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[166], &bstrm->context_array[166], 29*sizeof(CABAC_CONTEXT));
    }else{
        memcpy( &state->context_array[277], &bstrm->context_array[277], 29*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[388], &bstrm->context_array[388], 29*sizeof(CABAC_CONTEXT));
    }

    state->context_array[276] = bstrm->context_array[276]; //end of slice flag
    state->context_array[399] = bstrm->context_array[399]; //transform 8x8 flag
    state->context_array[400] = bstrm->context_array[400]; //transform 8x8 flag
    state->context_array[401] = bstrm->context_array[401]; //transform 8x8 flag
//    m_lcodIRange = bstrm->m_lcodIRange;
}

// ---------------------------------------------------------------------------

void H264BsBase_CopyContextCABAC_InterP(
    H264BsBase* state,
    H264BsBase* bstrm,
    Ipp32s isFrame,
    Ipp32s is8x8)
{
    memcpy( &state->context_array[11], &bstrm->context_array[11], 13*sizeof(CABAC_CONTEXT));
    memcpy( &state->context_array[40], &bstrm->context_array[40], 28*sizeof(CABAC_CONTEXT));
    memcpy( &state->context_array[70], &bstrm->context_array[70], 35*sizeof(CABAC_CONTEXT));

    memcpy( &state->context_array[227+30], &bstrm->context_array[227+30], 19*sizeof(CABAC_CONTEXT));
    if( isFrame ){
        memcpy( &state->context_array[105+44], &bstrm->context_array[105+44], 17*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[166+44], &bstrm->context_array[166+44], 17*sizeof(CABAC_CONTEXT));
        if( is8x8 ){
            memcpy( &state->context_array[426], &bstrm->context_array[426], 10*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[402], &bstrm->context_array[402], 24*sizeof(CABAC_CONTEXT));
        }else{
            memcpy( &state->context_array[105+29], &bstrm->context_array[105+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[166+29], &bstrm->context_array[166+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[227+20], &bstrm->context_array[227+20], 10*sizeof(CABAC_CONTEXT));
        }
    }else{
        memcpy( &state->context_array[105+172+44], &bstrm->context_array[105+172+44], 17*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[166+172+44], &bstrm->context_array[166+172+44], 17*sizeof(CABAC_CONTEXT));
        if( is8x8 ){
            memcpy( &state->context_array[426], &bstrm->context_array[426], 10*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[436], &bstrm->context_array[436], 24*sizeof(CABAC_CONTEXT));
        }else{
            memcpy( &state->context_array[105+172+29], &bstrm->context_array[105+172+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[166+172+29], &bstrm->context_array[166+172+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[227+172+20], &bstrm->context_array[227+172+20], 10*sizeof(CABAC_CONTEXT));
        }
    }

    state->context_array[276] = bstrm->context_array[276]; //end of slice flag
    state->context_array[399] = bstrm->context_array[399]; //transform 8x8 flag
    state->context_array[400] = bstrm->context_array[400]; //transform 8x8 flag
    state->context_array[401] = bstrm->context_array[401]; //transform 8x8 flag
//    m_lcodIRange = bstrm->m_lcodIRange;
}

// ---------------------------------------------------------------------------

void H264BsBase_CopyContextCABAC_InterB(
    H264BsBase* state,
    H264BsBase* bstrm,
    Ipp32s isFrame,
    Ipp32s is8x8)
{
    memcpy( &state->context_array[24], &bstrm->context_array[24], 16*sizeof(CABAC_CONTEXT));
    memcpy( &state->context_array[40], &bstrm->context_array[40], 28*sizeof(CABAC_CONTEXT));
    memcpy( &state->context_array[70], &bstrm->context_array[70], 35*sizeof(CABAC_CONTEXT));

    memcpy( &state->context_array[227+30], &bstrm->context_array[227+30], 19*sizeof(CABAC_CONTEXT));
    if( isFrame ){
        memcpy( &state->context_array[105+44], &bstrm->context_array[105+44], 17*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[166+44], &bstrm->context_array[166+44], 17*sizeof(CABAC_CONTEXT));
        if( is8x8 ){
            memcpy( &state->context_array[426], &bstrm->context_array[426], 10*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[402], &bstrm->context_array[402], 24*sizeof(CABAC_CONTEXT));
        }else{
            memcpy( &state->context_array[105+29], &bstrm->context_array[105+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[166+29], &bstrm->context_array[166+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[227+20], &bstrm->context_array[227+20], 10*sizeof(CABAC_CONTEXT));
        }
    }else{
        memcpy( &state->context_array[105+172+44], &bstrm->context_array[105+172+44], 17*sizeof(CABAC_CONTEXT));
        memcpy( &state->context_array[166+172+44], &bstrm->context_array[166+172+44], 17*sizeof(CABAC_CONTEXT));
        if( is8x8 ){
            memcpy( &state->context_array[426], &bstrm->context_array[426], 10*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[436], &bstrm->context_array[436], 24*sizeof(CABAC_CONTEXT));
        }else{
            memcpy( &state->context_array[105+172+29], &bstrm->context_array[105+172+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[166+172+29], &bstrm->context_array[166+172+29], 15*sizeof(CABAC_CONTEXT));
            memcpy( &state->context_array[227+172+20], &bstrm->context_array[227+172+20], 10*sizeof(CABAC_CONTEXT));
        }
    }

    state->context_array[276] = bstrm->context_array[276]; //end of slice flag
    state->context_array[399] = bstrm->context_array[399]; //transform 8x8 flag
    state->context_array[400] = bstrm->context_array[400]; //transform 8x8 flag
    state->context_array[401] = bstrm->context_array[401]; //transform 8x8 flag
//    m_lcodIRange = bstrm->m_lcodIRange;
}

// ---------------------------------------------------------------------------

const Ipp8u bitcountLPS[128][4] = {
{ 1, 1, 1, 1,  },
{ 1, 1, 1, 1,  },
{ 1, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 2, 1, 1,  },
{ 2, 2, 1, 1,  },
{ 2, 2, 1, 1,  },
{ 2, 2, 2, 1,  },
{ 2, 2, 2, 1,  },
{ 2, 2, 2, 1,  },
{ 2, 2, 2, 2,  },
{ 2, 2, 2, 2,  },
{ 2, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 3, 2, 2,  },
{ 3, 3, 2, 2,  },
{ 3, 3, 2, 2,  },
{ 3, 3, 3, 2,  },
{ 3, 3, 3, 2,  },
{ 3, 3, 3, 2,  },
{ 3, 3, 3, 3,  },
{ 3, 3, 3, 3,  },
{ 3, 3, 3, 3,  },
{ 3, 3, 3, 3,  },
{ 4, 3, 3, 3,  },
{ 4, 3, 3, 3,  },
{ 4, 3, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 4, 3,  },
{ 4, 4, 4, 3,  },
{ 4, 4, 4, 4,  },
{ 4, 4, 4, 4,  },
{ 4, 4, 4, 4,  },
{ 4, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 5, 4, 4,  },
{ 5, 5, 4, 4,  },
{ 5, 5, 4, 4,  },
{ 5, 5, 5, 4,  },
{ 5, 5, 5, 4,  },
{ 5, 5, 5, 4,  },
{ 5, 5, 5, 5,  },
{ 5, 5, 5, 5,  },
{ 5, 5, 5, 5,  },
{ 5, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 6, 5, 5,  },
{ 6, 6, 5, 5,  },
{ 6, 6, 6, 6,  },
{ 1, 1, 1, 1,  },
{ 1, 1, 1, 1,  },
{ 1, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 1, 1, 1,  },
{ 2, 2, 1, 1,  },
{ 2, 2, 1, 1,  },
{ 2, 2, 1, 1,  },
{ 2, 2, 2, 1,  },
{ 2, 2, 2, 1,  },
{ 2, 2, 2, 1,  },
{ 2, 2, 2, 2,  },
{ 2, 2, 2, 2,  },
{ 2, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 2, 2, 2,  },
{ 3, 3, 2, 2,  },
{ 3, 3, 2, 2,  },
{ 3, 3, 2, 2,  },
{ 3, 3, 3, 2,  },
{ 3, 3, 3, 2,  },
{ 3, 3, 3, 2,  },
{ 3, 3, 3, 3,  },
{ 3, 3, 3, 3,  },
{ 3, 3, 3, 3,  },
{ 3, 3, 3, 3,  },
{ 4, 3, 3, 3,  },
{ 4, 3, 3, 3,  },
{ 4, 3, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 3, 3,  },
{ 4, 4, 4, 3,  },
{ 4, 4, 4, 3,  },
{ 4, 4, 4, 4,  },
{ 4, 4, 4, 4,  },
{ 4, 4, 4, 4,  },
{ 4, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 4, 4, 4,  },
{ 5, 5, 4, 4,  },
{ 5, 5, 4, 4,  },
{ 5, 5, 4, 4,  },
{ 5, 5, 5, 4,  },
{ 5, 5, 5, 4,  },
{ 5, 5, 5, 4,  },
{ 5, 5, 5, 5,  },
{ 5, 5, 5, 5,  },
{ 5, 5, 5, 5,  },
{ 5, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 5, 5, 5,  },
{ 6, 6, 5, 5,  },
{ 6, 6, 5, 5,  },
{ 6, 6, 6, 6,  },
};

const Ipp16u rangeLPS[128][4] = {
{ 256, 352, 416, 480,  },
{ 256, 334, 394, 454,  },
{ 256, 316, 374, 432,  },
{ 492, 300, 356, 410,  },
{ 464, 284, 338, 390,  },
{ 444, 270, 320, 370,  },
{ 420, 256, 304, 350,  },
{ 400, 488, 288, 332,  },
{ 380, 464, 274, 316,  },
{ 360, 440, 260, 300,  },
{ 340, 416, 492, 284,  },
{ 324, 396, 468, 270,  },
{ 308, 376, 444, 256,  },
{ 292, 356, 420, 488,  },
{ 276, 340, 400, 464,  },
{ 264, 320, 380, 440,  },
{ 496, 304, 360, 416,  },
{ 472, 288, 344, 396,  },
{ 448, 276, 324, 376,  },
{ 424, 260, 308, 356,  },
{ 408, 496, 292, 340,  },
{ 384, 472, 276, 320,  },
{ 368, 448, 264, 304,  },
{ 344, 424, 504, 288,  },
{ 328, 400, 472, 276,  },
{ 312, 384, 448, 260,  },
{ 296, 360, 432, 496,  },
{ 280, 344, 408, 472,  },
{ 264, 328, 384, 448,  },
{ 256, 312, 368, 424,  },
{ 480, 296, 344, 400,  },
{ 464, 280, 328, 384,  },
{ 432, 264, 312, 360,  },
{ 416, 496, 296, 344,  },
{ 384, 480, 280, 328,  },
{ 368, 448, 264, 312,  },
{ 352, 432, 256, 296,  },
{ 336, 416, 480, 280,  },
{ 320, 384, 464, 264,  },
{ 304, 368, 432, 496,  },
{ 288, 352, 416, 480,  },
{ 272, 336, 400, 448,  },
{ 256, 320, 368, 432,  },
{ 480, 304, 352, 400,  },
{ 448, 288, 336, 384,  },
{ 448, 272, 320, 368,  },
{ 416, 256, 304, 352,  },
{ 384, 480, 288, 336,  },
{ 384, 448, 272, 320,  },
{ 352, 448, 256, 304,  },
{ 352, 416, 480, 288,  },
{ 320, 384, 480, 272,  },
{ 320, 384, 448, 256,  },
{ 288, 352, 416, 480,  },
{ 288, 352, 384, 448,  },
{ 256, 320, 384, 448,  },
{ 256, 288, 352, 416,  },
{ 448, 288, 352, 384,  },
{ 448, 288, 320, 384,  },
{ 448, 256, 320, 352,  },
{ 384, 256, 288, 352,  },
{ 384, 448, 288, 320,  },
{ 384, 448, 256, 288,  },
{ 128, 128, 128, 128,  },
{ 256, 352, 416, 480,  },
{ 256, 334, 394, 454,  },
{ 256, 316, 374, 432,  },
{ 492, 300, 356, 410,  },
{ 464, 284, 338, 390,  },
{ 444, 270, 320, 370,  },
{ 420, 256, 304, 350,  },
{ 400, 488, 288, 332,  },
{ 380, 464, 274, 316,  },
{ 360, 440, 260, 300,  },
{ 340, 416, 492, 284,  },
{ 324, 396, 468, 270,  },
{ 308, 376, 444, 256,  },
{ 292, 356, 420, 488,  },
{ 276, 340, 400, 464,  },
{ 264, 320, 380, 440,  },
{ 496, 304, 360, 416,  },
{ 472, 288, 344, 396,  },
{ 448, 276, 324, 376,  },
{ 424, 260, 308, 356,  },
{ 408, 496, 292, 340,  },
{ 384, 472, 276, 320,  },
{ 368, 448, 264, 304,  },
{ 344, 424, 504, 288,  },
{ 328, 400, 472, 276,  },
{ 312, 384, 448, 260,  },
{ 296, 360, 432, 496,  },
{ 280, 344, 408, 472,  },
{ 264, 328, 384, 448,  },
{ 256, 312, 368, 424,  },
{ 480, 296, 344, 400,  },
{ 464, 280, 328, 384,  },
{ 432, 264, 312, 360,  },
{ 416, 496, 296, 344,  },
{ 384, 480, 280, 328,  },
{ 368, 448, 264, 312,  },
{ 352, 432, 256, 296,  },
{ 336, 416, 480, 280,  },
{ 320, 384, 464, 264,  },
{ 304, 368, 432, 496,  },
{ 288, 352, 416, 480,  },
{ 272, 336, 400, 448,  },
{ 256, 320, 368, 432,  },
{ 480, 304, 352, 400,  },
{ 448, 288, 336, 384,  },
{ 448, 272, 320, 368,  },
{ 416, 256, 304, 352,  },
{ 384, 480, 288, 336,  },
{ 384, 448, 272, 320,  },
{ 352, 448, 256, 304,  },
{ 352, 416, 480, 288,  },
{ 320, 384, 480, 272,  },
{ 320, 384, 448, 256,  },
{ 288, 352, 416, 480,  },
{ 288, 352, 384, 448,  },
{ 256, 320, 384, 448,  },
{ 256, 288, 352, 416,  },
{ 448, 288, 352, 384,  },
{ 448, 288, 320, 384,  },
{ 448, 256, 320, 352,  },
{ 384, 256, 288, 352,  },
{ 384, 448, 288, 320,  },
{ 384, 448, 256, 288,  },
{ 128, 128, 128, 128,  },
};

const Ipp32s p_bits[128]={
//MPS bits
 246,  232,  220,  206,
 192,  179,  167,  157,
 148,  138,  129,  122,
 115,  108,  102,   96,
  90,   85,   80,   75,
  72,   67,   64,   60,
  57,   54,   51,   48,
  45,   43,   41,   39,
  36,   35,   33,   31,
  30,   28,   26,   25,
  24,   23,   21,   20,
  19,   18,   17,   16,
  15,   15,   14,   13,
  13,   12,   11,   11,
  10,    9,    9,    9,
   8,    8,    7,    2,
//LPS bits
 266,  282,  296,  314,
 334,  353,  373,  391,
 410,  430,  450,  468,
 488,  507,  526,  545,
 566,  584,  603,  624,
 641,  662,  679,  700,
 720,  738,  757,  776,
 796,  813,  835,  852,
 874,  893,  912,  933,
 948,  967,  987, 1008,
1024, 1044, 1065, 1087,
1106, 1120, 1141, 1164,
1180, 1198, 1216, 1237,
1249, 1280, 1294, 1313,
1338, 1358, 1366, 1385,
1409, 1430, 1451, 1928
};

#define FlushBitStream_CABAC while (m_nReadyBits!=8) WriteBit_CABAC(0)

const Ipp8s Table_9_34[3][64] =
{
    {0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5, 4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9, 10, 9, 8, 7, 7, 6, 11, 12, 13, 11, 6, 7, 8, 9, 14, 10, 9, 8, 6, 11, 12, 13, 11, 6, 9, 14, 10, 9, 11, 12, 13, 11, 14, 10, 12 },
    {0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5, 6, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 13, 13, 9, 9, 10, 10, 8, 13, 13, 9, 9, 10, 10, 14, 14, 14, 14, 14 },
    {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8 }
};

// Note, the following table is indexed by RunBefore & ZerosLeft-1
// Up to ZeroLeft = 7.  Above 7, Use 7.



///////////////////////////////////////////////////



/*Status H264BsReal_Create)(
    H264BsReal* state)
{
    return H264BsReal_Create)(state, NULL, 0);
}

Status H264BsFake_Create)(
    H264BsFake* state);
{
    return H264BsFake_Create)(state, NULL, 0);
}*/

// ---------------------------------------------------------------------------
//  CBaseBitstream::CBaseBitstream()
//      Constructs a new object.  Sets base pointer to point to the given
//      bitstream buffer.  Neither the encoder or the decoder allocates
//      memory for the bitstream buffer.
//      pb      : pointer to input bitstream
//      maxsize : size of bitstream
// ---------------------------------------------------------------------------

Status H264BsReal_Create(
    H264BsReal* state,
    Ipp8u* const pb,
    const Ipp32u maxsize,
    Ipp32s chroma_format_idc,
    Status &plr)
{
    H264BsReal* bs = (H264BsReal *)state;
    bs->m_base.m_pbsBase   = pb;
    bs->m_base.m_pbs       = pb;
    bs->m_base.m_bitOffset = 0;
    bs->m_base.m_maxBsSize = maxsize;

    bs->m_pbsRBSPBase = pb;
    plr = UMC_OK;

    if (chroma_format_idc)
        bs->num8x8Cshift2 = chroma_format_idc - 1;
    else
        bs->num8x8Cshift2 = 0;

    return UMC_OK;
}

void H264BsReal_Destroy( H264BsReal*)
{
}

Status H264BsFake_Create(
    H264BsFake* state,
    Ipp8u* const pb,
    const Ipp32u maxsize,
    Ipp32s chroma_format_idc,
    Status &plr)
{
    H264BsFake* bs = (H264BsFake *)state;
    bs->m_base.m_pbsBase   = pb;
    bs->m_base.m_pbs       = pb;
    bs->m_base.m_bitOffset = 0;
    bs->m_base.m_maxBsSize = maxsize;

    bs->m_pbsRBSPBase = pb;
    plr = UMC_OK;

    if (chroma_format_idc)
        bs->num8x8Cshift2 = chroma_format_idc - 1;
    else
        bs->num8x8Cshift2 = 0;

    return UMC_OK;
}

// ---------------------------------------------------------------------------
//  [ENC] CBaseBitstream::PutBits()
//      This is a special debug version that Detects Start Code Emulations.
//      Appends bits into the bitstream buffer.  Supports only up to 24 bits.
//
//      code        : code to be inserted into the bitstream
//      code_length : length of the given code in number of bits
// ---------------------------------------------------------------------------

void H264BsReal_PutBit(
    void* state,
    Ipp32u code)
{
    H264BsReal* bs = (H264BsReal *)state;
    if (code & 1)
        bs->m_base.m_pbs[0] =
            (Ipp8u)(bs->m_base.m_pbs[0] | (Ipp8u)(0x01 << (7 - bs->m_base.m_bitOffset)));
    //else
    //    bs->m_base.m_pbs[0] =
    //        (Ipp8u)(bs->m_base.m_pbs[0] & (Ipp8u)(0xff << (8 - bs->m_base.m_bitOffset)));

    bs->m_base.m_bitOffset++;
    if (bs->m_base.m_bitOffset == 8)
    {
        bs->m_base.m_pbs++;
        bs->m_base.m_pbs[0] = 0;
        bs->m_base.m_bitOffset = 0;
    }
}

void H264BsReal_PutBits(
    void* state,
    Ipp32u code,
    Ipp32u length)
{
    H264BsReal* bs = (H264BsReal *)state;
    // make sure that the number of bits given is <= 24
    // clear any nonzero bits in upper part of code
    VM_ASSERT(length <= 24);
    code <<= (32 - length);

    // shift field so that the given code begins at the current bit
    // offset in the most significant byte of the 32-bit word
    length += bs->m_base.m_bitOffset;
    code >>= bs->m_base.m_bitOffset;

    // write bytes back into memory, big-endian
    bs->m_base.m_pbs[0] = (Ipp8u)((code >> 24) | bs->m_base.m_pbs[0]);
    bs->m_base.m_pbs[1] = (Ipp8u)(code >> 16);
//f
    bs->m_base.m_pbs[2] = 0;
    if (length > 16)
    {
        bs->m_base.m_pbs[2] = (Ipp8u)(code >> 8);
        bs->m_base.m_pbs[3] = (Ipp8u)(code);
    }

    // update bitstream pointer and bit offset
    bs->m_base.m_pbs += (length >> 3);
    bs->m_base.m_bitOffset = (length & 7);
}

// ---------------------------------------------------------------------------
//  [ENC] CBaseBitstream::PutVLCCode()
//      Writes one Exp-Golomb code to the bitstream.  Automatically calculates
//      the required code length.  Use only when this can not be implicitly
//      known to the calling code, requiring length calculation anyway.
//
//      code        : code to be inserted into the bitstream
// ---------------------------------------------------------------------------

Ipp32u H264BsReal_PutVLCCode(
    void* state,
    const Ipp32u code)
{
    Ipp32s i, NN;
    Ipp32u code_length;
    NN = code + 1;

#if defined(__i386__) && defined(__GNUC__) && (__GNUC__ > 3) && !defined(__INTEL_COMPILER)
    i = 31 - __builtin_clz(NN);
#elif defined(__INTEL_COMPILER) && (defined(__i386__) || defined(WINDOWS)) && !defined(INTEL64)
    i = _bit_scan_reverse( NN );
#elif defined(_MSC_VER) && (_MSC_FULL_VER >= 140050110) && !defined(__INTEL_COMPILER)
    unsigned long idx;
    _BitScanReverse(&idx, (unsigned long)NN);
    i = (Ipp32s)idx;
#else
    i = -1;
    while (NN) {
        NN >>= 1;
        i++;
    }
#endif

    code_length = 1 + (i << 1);
//f    PutVLCBits(code,code_length);
    if (code_length == 1)
        H264BsReal_PutBit(state, 1);
    else {
        Ipp32s info_length = (code_length - 1) >> 1;
        Ipp32s bits = code + 1 - (1 << info_length);
        H264BsReal_PutBits(state, 1, info_length + 1);
        H264BsReal_PutBits(state, bits, info_length);
    }

    return code_length;
}

// ---------------------------------------------------------------------------
//  [ENC] CBaseBitstream::PutVLCBits()
//      Writes one Exp-Golomb code to the bitstream.
//      code        : code to be inserted into the bitstream
//      code_length : length of the given code in number of bits
// ---------------------------------------------------------------------------

void H264BsReal_PutVLCBits(
    H264BsReal* state,
    const Ipp32u code,
    const Ipp32u code_length)
{
    Ipp32s info_length, bits;

    if (code_length == 1){
        H264BsReal_PutBit(state, 1);
        return;
    }

    info_length = (code_length-1) >> 1;
    bits = code+1-(1<<info_length);

    H264BsReal_PutBits(state, 0, info_length);
    H264BsReal_PutBit(state, 1);
    H264BsReal_PutBits(state, bits, info_length);
}

void H264BsReal_SaveCABACState(
    void* state)
{
    H264BsReal* bs = (H264BsReal *)state;
    memcpy(&bs->context_array_copy[0], &bs->m_base.context_array[0], 460 * sizeof(CABAC_CONTEXT));
    bs->m_lcodIRange_copy = bs->m_base.m_lcodIRange;
    bs->m_lcodIOffset_copy = bs->m_base.m_lcodIOffset;
    bs->m_nRegister_copy = bs->m_base.m_nRegister;
    bs->m_nReadyBits_copy = bs->m_base.m_nReadyBits;
    bs->m_pbs_copy = bs->m_base.m_pbs;
    bs->m_bitOffset_copy = bs->m_base.m_bitOffset;

#ifdef CABAC_FAST
    bs->m_nReadyBytes_copy = bs->m_base.m_nReadyBytes;
    bs->m_nOutstandingChunks_copy = bs->m_base.m_nOutstandingChunks;
#else
    bs->m_nOutstandingBits_copy = bs->m_base.m_nOutstandingBits;
#endif
}

void H264BsReal_RestoreCABACState(
    void* state)
{
    H264BsReal* bs = (H264BsReal *)state;
    memcpy(&bs->m_base.context_array[0], &bs->context_array_copy[0], 460*sizeof(CABAC_CONTEXT));
    bs->m_base.m_lcodIRange = bs->m_lcodIRange_copy;
    bs->m_base.m_lcodIOffset = bs->m_lcodIOffset_copy;
    bs->m_base.m_nRegister = bs->m_nRegister_copy;
    bs->m_base.m_nReadyBits = bs->m_nReadyBits_copy;
    bs->m_base.m_pbs = bs->m_pbs_copy;
    bs->m_base.m_bitOffset =  bs->m_bitOffset_copy;
#ifdef CABAC_FAST
    bs->m_base.m_nReadyBytes = bs->m_nReadyBytes_copy;
    bs->m_base.m_nOutstandingChunks = bs->m_nOutstandingChunks_copy;
#else
    bs->m_base.m_nOutstandingBits = bs->m_nOutstandingBits_copy;
#endif
}

void H264BsReal_CopyContext_CABAC(
    void* state,
    H264BsBase* bstrm,
    Ipp32s isFrame,
    Ipp32s is8x8)
{
    H264BsReal* bs = (H264BsReal *)state;
    memcpy(&bs->m_base.context_array[0],   &bstrm->context_array[0],  105*sizeof(CABAC_CONTEXT));
    memcpy(&bs->m_base.context_array[227], &bstrm->context_array[227], 49*sizeof(CABAC_CONTEXT));
    if (isFrame)
        memcpy(&bs->m_base.context_array[105], &bstrm->context_array[105], 122*sizeof(CABAC_CONTEXT));
    else
        memcpy(&bs->m_base.context_array[277], &bstrm->context_array[277], 122*sizeof(CABAC_CONTEXT));

    if (is8x8)
    {
        memcpy(&bs->m_base.context_array[426], &bstrm->context_array[426], 10*sizeof(CABAC_CONTEXT));
        if (isFrame)
            memcpy(&bs->m_base.context_array[402], &bstrm->context_array[402], 24*sizeof(CABAC_CONTEXT));
        else
            memcpy(&bs->m_base.context_array[436], &bstrm->context_array[436], 24*sizeof(CABAC_CONTEXT));
    }

    bs->m_base.context_array[276] = bstrm->context_array[276]; //end of slice flag
    bs->m_base.context_array[399] = bstrm->context_array[399]; //transform 8x8 flag
    bs->m_base.context_array[400] = bstrm->context_array[400]; //transform 8x8 flag
    bs->m_base.context_array[401] = bstrm->context_array[401]; //transform 8x8 flag
/*
    bs->m_base.m_lcodIRange = bstrm->m_lcodIRange;
    bs->m_base.m_lcodIOffset = bstrm->m_lcodIOffset;
    bs->m_base.m_nRegister = bstrm->m_nRegister;
    bs->m_base.m_nReadyBits = bstrm->m_nReadyBits;
    bs->m_base.m_nOutstandingBits = bstrm->m_nOutstandingBits;
*/
}

void H264BsReal_ResetBitStream_CABAC(
    void* state)
{
    H264BsReal* bs = (H264BsReal *)state;
    bs->m_base.m_lcodIOffset = 0;
    bs->m_base.m_nRegister = 0;
#ifdef CABAC_FAST
    bs->m_base.m_lcodIRange = ENC_M_HALF - 2;
    bs->m_base.m_nReadyBits = ENC_M_BITS + 1;
    bs->m_base.m_nReadyBytes = 0;
    bs->m_base.m_nOutstandingChunks = 0;
#else
    bs->m_base.m_lcodIRange=ENC_HALF_RANGE-2;
    bs->m_base.m_nReadyBits = 33;
//  bs->m_base.m_nReadyBits = 9;
    bs->m_base.m_nOutstandingBits = 0;
#endif
    H264BsBase_ByteAlignWithOnes(&bs->m_base);
}

#ifdef CABAC_FAST
void H264BsReal_WriteTwoBytes_CABAC(
    void* state,
    Ipp32u b)
{
    H264BsReal* bs = (H264BsReal *)state;
    if (bs->m_base.m_nReadyBytes == 4)
    {
        *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister);
        bs->m_base.m_nRegister = bs->m_base.m_nReadyBytes = 0;
    }
    else if (bs->m_base.m_nReadyBytes == 3)
    {
        *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister);
        bs->m_base.m_nReadyBytes = bs->m_base.m_nRegister = 0;
    }
    bs->m_base.m_nRegister <<= 16;
    bs->m_base.m_nRegister |= b;
    bs->m_base.m_nReadyBytes++;
    bs->m_base.m_nReadyBytes++;
    return;
}

void H264BsReal_WriteOneByte_CABAC(
    void* state,
    Ipp32u b)
{
    H264BsReal* bs = (H264BsReal *)state;
    if (bs->m_base.m_nReadyBytes > 0)
    {
        switch (bs->m_base.m_nReadyBytes)
        {
            case 4:
                *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
                *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
                *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
                *(bs->m_base.m_pbs+3) = (Ipp8u)(bs->m_base.m_nRegister);
                bs->m_base.m_pbs += 4;
                break;
            case 3:
                *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>16);
                *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>8);
                *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister);
                bs->m_base.m_pbs += 3;
                break;
            case 2:
                *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>8);
                *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister);
                bs->m_base.m_pbs += 2;
                break;
            case 1:
                *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister);
                bs->m_base.m_pbs++;
                break;
        }
        bs->m_base.m_nReadyBytes =  bs->m_base.m_nRegister = 0;
    }
    *(bs->m_base.m_pbs) = (Ipp8u)(b);
    bs->m_base.m_pbs++;
}
#else

void H264BsReal_WriteBit_CABAC(
    H264BsReal* state,
    bool code)
{
    H264BsReal* bs = (H264BsReal *)state;
    bs->m_base.m_nRegister <<= 1;
    bs->m_base.m_nRegister |= (Ipp32s)code;
    bs->m_base.m_nReadyBits --;
    if (0 == bs->m_base.m_nReadyBits)
    {
        *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs+3) = (Ipp8u)bs->m_base.m_nRegister;
        bs->m_base.m_pbs += 4;
        bs->m_base.m_nRegister = 0;
        bs->m_base.m_nReadyBits = 32;
        //m_nReadyBits = 8;
    }
    return;
}

void H264BsReal_WriteOutstandingBit_CABAC(
    H264BsReal* state,
    bool code)
{
    H264BsReal* bs = (H264BsReal *)state;
    H264BsReal_WriteBit_CABAC(bs, code);
    while (bs->m_base.m_nOutstandingBits > 0)
    {
        bs->m_base.m_nOutstandingBits--;
        H264BsReal_WriteBit_CABAC(bs, !code);
    }
}

void H264BsReal_WriteOutstandingZeroBit_CABAC(
    H264BsReal* state)
{
    H264BsReal* bs = (H264BsReal *)state;
    bs->m_base.m_nRegister <<= 1;
    //bs->m_base.m_nRegister |= 0;
    bs->m_base.m_nReadyBits --;
    if (0 == bs->m_base.m_nReadyBits)
    {
        *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs+3) = (Ipp8u)bs->m_base.m_nRegister;
        bs->m_base.m_pbs += 4;
        bs->m_base.m_nRegister = 0;
        bs->m_base.m_nReadyBits = 32;
    }

    if (bs->m_base.m_nReadyBits < bs->m_base.m_nOutstandingBits)
    {
        bs->m_base.m_nRegister <<= bs->m_base.m_nReadyBits;
        bs->m_base.m_nRegister |= (Ipp32u)0xffffffff >> (32-bs->m_base.m_nReadyBits);
        *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs+3) = (Ipp8u)bs->m_base.m_nRegister;
        bs->m_base.m_pbs += 4;
        bs->m_base.m_nOutstandingBits -= bs->m_base.m_nReadyBits;
        bs->m_base.m_nRegister = 0;
        bs->m_base.m_nReadyBits = 32;
        while (bs->m_base.m_nOutstandingBits >= 32)
        {
            *(bs->m_base.m_pbs) = 0xff;
            *(bs->m_base.m_pbs+1) = 0xff;
            *(bs->m_base.m_pbs+2) = 0xff;
            *(bs->m_base.m_pbs+3) = 0xff;
            bs->m_base.m_pbs += 4;
            bs->m_base.m_nOutstandingBits -= 32;
        }
    }

    if (bs->m_base.m_nOutstandingBits == 0)
        return;

    bs->m_base.m_nRegister <<= bs->m_base.m_nOutstandingBits;
    bs->m_base.m_nRegister |= (Ipp32u)0xffffffff >> (32-bs->m_base.m_nOutstandingBits);
    bs->m_base.m_nReadyBits -= bs->m_base.m_nOutstandingBits;
    if (0 == bs->m_base.m_nReadyBits)
    {
        *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs+3) = (Ipp8u)bs->m_base.m_nRegister;
        bs->m_base.m_pbs += 4;
        bs->m_base.m_nRegister = 0;
        bs->m_base.m_nReadyBits = 32;
    }
    bs->m_base.m_nOutstandingBits = 0;
}

void H264BsReal_WriteOutstandingOneBit_CABAC(
    H264BsReal* state)
{
    H264BsReal* bs = (H264BsReal *)state;
    bs->m_base.m_nRegister <<= 1;
    bs->m_base.m_nRegister |= 1;
    bs->m_base.m_nReadyBits --;
    if (0 == bs->m_base.m_nReadyBits)
    {
        *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs+3) = (Ipp8u)bs->m_base.m_nRegister;
        bs->m_base.m_pbs += 4;
        bs->m_base.m_nRegister = 0;
        bs->m_base.m_nReadyBits = 32;
    }

    if (bs->m_base.m_nReadyBits < bs->m_base.m_nOutstandingBits)
    {
        bs->m_base.m_nRegister <<= bs->m_base.m_nReadyBits;
        bs->m_base.m_nRegister &= (Ipp32u)0xffffffff << bs->m_base.m_nReadyBits;
        *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs+3) = (Ipp8u)bs->m_base.m_nRegister;
        bs->m_base.m_pbs += 4;
        bs->m_base.m_nOutstandingBits -= bs->m_base.m_nReadyBits;
        bs->m_base.m_nRegister = 0;
        bs->m_base.m_nReadyBits = 32;
        while( bs->m_base.m_nOutstandingBits >= 32 ){
            *(bs->m_base.m_pbs) = 0;
            *(bs->m_base.m_pbs+1) = 0;
            *(bs->m_base.m_pbs+2) = 0;
            *(bs->m_base.m_pbs+3) = 0;
            bs->m_base.m_pbs += 4;
            bs->m_base.m_nOutstandingBits -= 32;
        }
    }

    if (bs->m_base.m_nOutstandingBits == 0)
        return;
    bs->m_base.m_nRegister <<= bs->m_base.m_nOutstandingBits;
    bs->m_base.m_nRegister &= (Ipp32u)0xffffffff << bs->m_base.m_nOutstandingBits;
    bs->m_base.m_nReadyBits -= bs->m_base.m_nOutstandingBits;
    if (0 == bs->m_base.m_nReadyBits)
    {
        *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>24);
        *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
        *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
        *(bs->m_base.m_pbs+3) = (Ipp8u)bs->m_base.m_nRegister;
        bs->m_base.m_pbs += 4;
        bs->m_base.m_nRegister = 0;
        bs->m_base.m_nReadyBits = 32;
    }
    bs->m_base.m_nOutstandingBits = 0;
}
#endif

#ifdef CABAC_FAST
void H264BsReal_EncodeSingleBin_CABAC(
    void* state_,
    Ipp8u* ctx,
    Ipp32s code)
{
    H264BsReal* bs = (H264BsReal *)state_;
    Ipp8u pStateIdx = *ctx;
    Ipp8u state;
    register Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    register Ipp32u codIRange = bs->m_base.m_lcodIRange;
    Ipp32u codIRangeLPS = rangeTabLPS[pStateIdx][((codIRange >> 6) & 0x03)];

    codIRange -= codIRangeLPS;

    state = pStateIdx>>6;
    pStateIdx = transTbl[code][pStateIdx];
    if (code != state ){
        Ipp8u Renorm;
        codIOffset += (codIRange<<bs->m_base.m_nReadyBits);
        codIRange = codIRangeLPS;

        Renorm = renormTAB[(codIRangeLPS>>3)&0x1f];
        bs->m_base.m_nReadyBits -= Renorm;
        codIRange <<= Renorm;
        if( codIOffset >= ENC_M_FULL ){ //carry
            codIOffset -= ENC_M_FULL;
            bs->m_base.m_nRegister++;
            while( bs->m_base.m_nOutstandingChunks > 0 ){
                H264BsReal_WriteTwoBytes_CABAC(bs, 0);
                bs->m_base.m_nOutstandingChunks--;
            }
        }
        if( bs->m_base.m_nReadyBits > 0 ){
            *ctx = pStateIdx;
            bs->m_base.m_lcodIOffset = codIOffset;
            bs->m_base.m_lcodIRange = codIRange;
            return;  //no output
        }
    }else{
        if( codIRange >= ENC_M_QUARTER ){
            *ctx = pStateIdx;
            bs->m_base.m_lcodIOffset = codIOffset;
            bs->m_base.m_lcodIRange = codIRange;
            return;
        }
        codIRange <<= 1;
        bs->m_base.m_nReadyBits--;
        if( bs->m_base.m_nReadyBits > 0 ){
            *ctx = pStateIdx;
            bs->m_base.m_lcodIOffset = codIOffset;
            bs->m_base.m_lcodIRange = codIRange;
            return;
        }
    }

    Ipp32s L = (codIOffset>>ENC_B_BITS)& ((1<<ENC_M_BITS)-1);
    codIOffset = (codIOffset<<ENC_M_BITS)&(ENC_M_FULL-1);
    if( L < ((1<<ENC_M_BITS)-1) ){
        while( bs->m_base.m_nOutstandingChunks > 0 ){
            H264BsReal_WriteTwoBytes_CABAC(state_, 0xffff);
            bs->m_base.m_nOutstandingChunks--;
        }
        H264BsReal_WriteTwoBytes_CABAC(state_, L);
    }else{
        bs->m_base.m_nOutstandingChunks++;
    }
    bs->m_base.m_nReadyBits += ENC_M_BITS;

    *ctx = pStateIdx;
    bs->m_base.m_lcodIOffset = codIOffset;
    bs->m_base.m_lcodIRange = codIRange;
}

#else

void H264BsReal_EncodeSingleBin_CABAC(
    void* state,
    Ipp8u* ctx,
    Ipp32s code)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp8u  pStateIdx = *ctx;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    Ipp32u codIRange = bs->m_base.m_lcodIRange;
    Ipp32u codIRangeLPS = rangeTabLPS[(pStateIdx)&0x7F][((codIRange >> 6) & 0x03)];

    codIRange -= codIRangeLPS;

    if (code != (pStateIdx >> 6))
    {
        codIOffset += codIRange;
        codIRange = codIRangeLPS;
    }
    pStateIdx = transTbl[code][pStateIdx];

    /* renormalisation */
    while (codIRange < ENC_QUARTER_RANGE)
    {
        if (codIOffset >= ENC_HALF_RANGE)
        {
            //H264BsReal_WriteOutstandingBit_CABAC(bs, 1);
            H264BsReal_WriteOutstandingOneBit_CABAC(bs);
            codIOffset -= ENC_HALF_RANGE;
        }
        else if (codIOffset < ENC_QUARTER_RANGE)
        {
            //H264BsReal_WriteOutstandingBit_CABAC(bs, 0);
            H264BsReal_WriteOutstandingZeroBit_CABAC(bs);
        }
        else
        {
            bs->m_base.m_nOutstandingBits++;
            codIOffset -= ENC_QUARTER_RANGE;
        }

        codIOffset <<= 1;
        codIRange <<= 1;
    }

    *ctx = pStateIdx;
    bs->m_base.m_lcodIOffset = codIOffset;
    bs->m_base.m_lcodIRange = codIRange;
}
#endif

#ifdef CABAC_FAST
void H264BsReal_EncodeBins_CABAC(
    void* state_,
    Ipp8u* ctx,
    Ipp32u code,
    Ipp32s len)
{
    H264BsReal* bs = (H264BsReal *)state_;
    Ipp8u pStateIdx = *ctx;
    Ipp8u state;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    register Ipp32u codIRange = bs->m_base.m_lcodIRange;
    Ipp32u codIRangeLPS;

    while (len > 0)
    {
        codIRangeLPS = rangeTabLPS[pStateIdx][((codIRange >> 6) & 0x03)];
        codIRange -= codIRangeLPS;

        len--;
        Ipp8u c = (Ipp8u)((code >> len) & 1);
        state = pStateIdx>>6;
        pStateIdx = transTbl[c][pStateIdx];
        if (c != state)
        {
            Ipp8u Renorm;
            codIOffset += (codIRange << bs->m_base.m_nReadyBits);
            codIRange = codIRangeLPS;

            Renorm = renormTAB[(codIRangeLPS>>3)&0x1f];
            bs->m_base.m_nReadyBits -= Renorm;
            codIRange <<= Renorm;
            if (codIOffset >= ENC_M_FULL)
            { //carry
                codIOffset -= ENC_M_FULL;
                bs->m_base.m_nRegister++;
                while (bs->m_base.m_nOutstandingChunks > 0)
                {
                    H264BsReal_WriteTwoBytes_CABAC(state_, 0);
                    bs->m_base.m_nOutstandingChunks--;
                }
            }
            if (bs->m_base.m_nReadyBits > 0)
                continue;
        }
        else
        {
            if (codIRange >= ENC_M_QUARTER)
                continue;
            codIRange <<= 1;
            bs->m_base.m_nReadyBits--;
            if (bs->m_base.m_nReadyBits > 0)
                continue;
        }

        Ipp32s L = (codIOffset >> ENC_B_BITS) & ((1 << ENC_M_BITS) - 1);
        codIOffset = (codIOffset << ENC_M_BITS) & (ENC_M_FULL - 1);
        if (L < ((1 << ENC_M_BITS) - 1))
        {
            while (bs->m_base.m_nOutstandingChunks > 0)
            {
                H264BsReal_WriteTwoBytes_CABAC(state_, 0xffff);
                bs->m_base.m_nOutstandingChunks--;
            }
            H264BsReal_WriteTwoBytes_CABAC(state_, L);
        }
        else
        {
            bs->m_base.m_nOutstandingChunks++;
        }
        bs->m_base.m_nReadyBits += ENC_M_BITS;
    }

    bs->m_base.m_lcodIRange = codIRange;
    *ctx = pStateIdx;
    bs->m_base.m_lcodIOffset = codIOffset;
}

#else
void H264BsReal_EncodeBins_CABAC(
    void* state,
    Ipp8u* ctx,
    Ipp32u code,
    Ipp32s len)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32u pStateIdx = *ctx;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    register Ipp32u codIRange = bs->m_base.m_lcodIRange;
    Ipp32u codIRangeLPS;

    while (len > 0)
    {
        codIRangeLPS = rangeTabLPS[pStateIdx][((codIRange >> 6) & 0x03)];
        codIRange -= codIRangeLPS;

        len--;
        Ipp32u c = (code>>len)&1;
        if(c != (pStateIdx>>6) ){
            codIOffset += codIRange;
            codIRange = codIRangeLPS;
        }
        pStateIdx = transTbl[c][pStateIdx];

        /* renormalisation */
        while (codIRange  < ENC_QUARTER_RANGE)
        {
            if (codIOffset >= ENC_HALF_RANGE)
            {
                H264BsReal_WriteOutstandingOneBit_CABAC(bs);
                codIOffset  -= ENC_HALF_RANGE;
            }
            else if (codIOffset < ENC_QUARTER_RANGE)
            {
                H264BsReal_WriteOutstandingZeroBit_CABAC(bs);
            }
            else
            {
                bs->m_base.m_nOutstandingBits++;
                codIOffset  -= ENC_QUARTER_RANGE;
            }

            codIOffset<<= 1;
            codIRange <<= 1;
        }
    }

    bs->m_base.m_lcodIRange = codIRange;
    *ctx = (Ipp8u)pStateIdx;
    bs->m_base.m_lcodIOffset = codIOffset;
}
#endif

#if 1
void H264BsFake_EncodeBins_CABAC(
    H264BsFake* state,
    Ipp8u* ctx,
    Ipp32u code,
    Ipp32s len)
{
    H264BsFake* bs = (H264BsFake *)state;
    register Ipp8u pStateIdx = *ctx;
    register Ipp32s bits=0;

    while (len>0)
    {
        len--;
        Ipp32u c = (code>>len)&1;
        bits += ( c ? p_bits[(pStateIdx^64)&0x7F] : p_bits[(pStateIdx)&0x7F] );
        pStateIdx = transTbl[c][pStateIdx];
    }

    *ctx = pStateIdx;
    bs->m_base.m_bitOffset += bits;
#if 0
    register Ipp8u pStateIdx = bs->m_base.context_array[ctxIdx].pStateIdx;
    register Ipp32u codIRange = bs->m_base.m_lcodIRange;

    while(len>0){
        len--;
        register Ipp8u idx = ((codIRange >> 6) & 0x03);
        Ipp8u c = (code>>len)&1;
        if (c != (pStateIdx>>6) ){
            bs->m_base.m_bitOffset += bitcountLPS[pStateIdx][idx];
            codIRange = rangeLPS[pStateIdx][idx];
        }else{
            codIRange -= rangeTabLPS[pStateIdx][idx];  //MPS range
            register Ipp32s renorm = (codIRange>>8)^1;
            bs->m_base.m_bitOffset +=  renorm;
            codIRange <<= renorm;
        }
        pStateIdx = transTbl[c][pStateIdx];
    }

    bs->m_base.m_lcodIRange = codIRange;
    bs->m_base.context_array[ctxIdx].pStateIdx = pStateIdx;
#endif
}
#endif

#ifdef CABAC_FAST
void H264BsReal_EncodeFinalSingleBin_CABAC(
    void* state,
    Ipp32s code)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    Ipp32u codIRange = bs->m_base.m_lcodIRange;
    codIRange -=2;
    if (code){ //LPS
        codIOffset += (codIRange<<bs->m_base.m_nReadyBits);
        codIRange  = 2;
        if( codIOffset >= ENC_M_FULL ){
            codIOffset -= ENC_M_FULL;
            bs->m_base.m_nRegister++;
            while( bs->m_base.m_nOutstandingChunks > 0 ){
                H264BsReal_WriteTwoBytes_CABAC(state, 0);
                bs->m_base.m_nOutstandingChunks--;
            }
        }
        bs->m_base.m_nReadyBits -= 7;
        codIRange <<= 7;
        if( bs->m_base.m_nReadyBits > 0 ){
            bs->m_base.m_lcodIOffset = codIOffset;
            bs->m_base.m_lcodIRange = codIRange;
            return;
        }
    }else{
        if( codIRange >= ENC_M_QUARTER ){
            bs->m_base.m_lcodIOffset = codIOffset;
            bs->m_base.m_lcodIRange = codIRange;
            return;
        }
        codIRange <<= 1;
        bs->m_base.m_nReadyBits--;
        if( bs->m_base.m_nReadyBits > 0 ){
            bs->m_base.m_lcodIOffset = codIOffset;
            bs->m_base.m_lcodIRange = codIRange;
            return;
        }
    }

    Ipp32s L = (codIOffset>>ENC_B_BITS)& ((1<<ENC_M_BITS)-1);
    codIOffset = (codIOffset<<ENC_M_BITS)&(ENC_M_FULL-1);
    if (L < ((1 << ENC_M_BITS) - 1))
    {
        while (bs->m_base.m_nOutstandingChunks > 0)
        {
            H264BsReal_WriteTwoBytes_CABAC(state, 0xffff);
            bs->m_base.m_nOutstandingChunks--;
        }
        H264BsReal_WriteTwoBytes_CABAC(state, L);
    }
    else
    {
        bs->m_base.m_nOutstandingChunks++;
    }

    bs->m_base.m_nReadyBits += ENC_M_BITS;
    bs->m_base.m_lcodIOffset = codIOffset;
    bs->m_base.m_lcodIRange = codIRange;
    return;
}

#else

void H264BsReal_EncodeFinalSingleBin_CABAC(
    void* state,
    Ipp32s code)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    Ipp32u codIRange = bs->m_base.m_lcodIRange;
    codIRange -=2;
    if (code)
    {
        codIOffset += codIRange ;
        codIRange  = 2;
    }

  /* renormalisation */
    while (codIRange  < ENC_QUARTER_RANGE)
    {
        if (codIOffset >= ENC_HALF_RANGE)
        {
            //H264BsReal_WriteOutstandingBit_CABAC(bs, 1);
            H264BsReal_WriteOutstandingOneBit_CABAC(bs);
            codIOffset -= ENC_HALF_RANGE;
        }
        else if (codIOffset < ENC_QUARTER_RANGE)
        {
            //H264BsReal_WriteOutstandingBit_CABAC(bs, 0);
            H264BsReal_WriteOutstandingZeroBit_CABAC(bs);
        }
        else
        {
            bs->m_base.m_nOutstandingBits++;
            codIOffset -= ENC_QUARTER_RANGE;
        }

        codIOffset <<= 1;
        codIRange <<= 1;
    }

    bs->m_base.m_lcodIOffset = codIOffset;
    bs->m_base.m_lcodIRange = codIRange;
    return;
}
#endif

#ifdef CABAC_FAST
void H264BsReal_EncodeBypass_CABAC(
    void* state,
    Ipp32s code)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    Ipp32u codIRange = bs->m_base.m_lcodIRange;
    bs->m_base.m_nReadyBits--;

    if (code)
    { //LPS
        codIOffset  += (codIRange<<bs->m_base.m_nReadyBits);
        if (codIOffset >= ENC_M_FULL)
        {
            codIOffset -= ENC_M_FULL;
            bs->m_base.m_nRegister++;
            while (bs->m_base.m_nOutstandingChunks > 0)
            {
                H264BsReal_WriteTwoBytes_CABAC(state, 0);
                bs->m_base.m_nOutstandingChunks--;
            }
        }
    }

    if (bs->m_base.m_nReadyBits == 0)
    {
        Ipp32s L = (codIOffset>>ENC_B_BITS)& ((1<<ENC_M_BITS)-1);
        codIOffset = (codIOffset<<ENC_M_BITS)&(ENC_M_FULL-1);
        if (L < ((1 << ENC_M_BITS) - 1))
        {
            while (bs->m_base.m_nOutstandingChunks > 0)
            {
                H264BsReal_WriteTwoBytes_CABAC(state, 0xffff);
                bs->m_base.m_nOutstandingChunks--;
            }
            H264BsReal_WriteTwoBytes_CABAC(state, L);
        }
        else
        {
            bs->m_base.m_nOutstandingChunks++;
        }

        bs->m_base.m_nReadyBits += ENC_M_BITS;
    }

    bs->m_base.m_lcodIOffset = codIOffset;
    bs->m_base.m_lcodIRange = codIRange;
    return;
}

#else

void H264BsReal_EncodeBypass_CABAC(
    void* state,
    Ipp32s code)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    Ipp32u codIRange = bs->m_base.m_lcodIRange;
    codIOffset *= 2;

    if (code)
        codIOffset += codIRange;

    if (codIOffset >= ENC_FULL_RANGE)
    {
        //H264BsReal_WriteOutstandingBit_CABAC(bs, 1);
        H264BsReal_WriteOutstandingOneBit_CABAC(bs);
        codIOffset -= ENC_FULL_RANGE;
    }
    else if (codIOffset < ENC_HALF_RANGE)
    {
        H264BsReal_WriteOutstandingZeroBit_CABAC(bs);
        //H264BsReal_WriteOutstandingBit_CABAC(bs, 0);
    }
    else
    {
        bs->m_base.m_nOutstandingBits++;
        codIOffset -= ENC_HALF_RANGE;
    }

    bs->m_base.m_lcodIOffset = codIOffset;
    bs->m_base.m_lcodIRange = codIRange;
    return;
}
#endif

#ifdef CABAC_FAST
void H264BsReal_TerminateEncode_CABAC(
    void* state)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32u codIOffset =  bs->m_base.m_lcodIOffset;
    Ipp32s remBits = ENC_M_BITS -  bs->m_base.m_nReadyBits;
    Ipp8u  mask;

    if (remBits <= 5)
    {
        mask = (Ipp8u)(255 - ((1 << (6 - remBits)) - 1));
        codIOffset = (codIOffset >> (ENC_B_BITS + 8)) & mask;
        codIOffset += (1 << (5 - remBits));
        while (bs->m_base.m_nOutstandingChunks > 0)
        {
            H264BsReal_WriteTwoBytes_CABAC(state, 0xffff);
            bs->m_base.m_nOutstandingChunks--;
        }

        H264BsReal_WriteOneByte_CABAC(state, codIOffset);
        //put buffer
    }
    else if (remBits <= 13)
    {
        Ipp32s L = (codIOffset >> (ENC_B_BITS + 8) & 0xff);
        while (bs->m_base.m_nOutstandingChunks > 0)
        {
            H264BsReal_WriteTwoBytes_CABAC(state, 0xffff);
            bs->m_base.m_nOutstandingChunks--;
        }

        H264BsReal_WriteOneByte_CABAC(state, L);
        //put buffer
        if (remBits > 6)
        {
            mask = (Ipp8u)(255 - ((1 << (14 - remBits)) - 1));
            codIOffset = (codIOffset >> ENC_B_BITS) & mask;
            codIOffset += (1 << (13 - remBits));
            H264BsReal_WriteOneByte_CABAC(state, codIOffset);
        }
        else
        {
            H264BsReal_WriteOneByte_CABAC(state, 128);
        }
    }
    else
    {
        Ipp32s L = (codIOffset >> (ENC_B_BITS) & ((1 << ENC_M_BITS) - 1));
        while (bs->m_base.m_nOutstandingChunks > 0)
        {
            H264BsReal_WriteTwoBytes_CABAC(state, 0xffff);
            bs->m_base.m_nOutstandingChunks--;
        }

        H264BsReal_WriteTwoBytes_CABAC(state, L);
        //put buffer
        if (remBits > 14)
        {
            mask = (Ipp8u)(255 - ((1<<(22-remBits))-1));
            codIOffset = (codIOffset>>(ENC_B_BITS - 8)) & mask;
            codIOffset += (1<<(21-remBits));
            H264BsReal_WriteOneByte_CABAC(state, codIOffset);
        }
        else
        {
            H264BsReal_WriteOneByte_CABAC(state, 128);
        }
    }

    bs->m_base.m_nReadyBits = 8;
    bs->m_base.m_lcodIOffset = codIOffset;
}

#else

void H264BsReal_TerminateEncode_CABAC(
    void* state)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32u codIOffset = bs->m_base.m_lcodIOffset;
    H264BsReal_WriteOutstandingBit_CABAC(bs, (codIOffset >> (ENC_B_BITS-1)) & 1);
    H264BsReal_WriteBit_CABAC(bs, (codIOffset >> (ENC_B_BITS - 2)) & 1);
    H264BsReal_WriteBit_CABAC(bs, 1);
    //FlushBitStream_CABAC;
    while (bs->m_base.m_nReadyBits & 7)
    {
        bs->m_base.m_nRegister <<= 1;
        bs->m_base.m_nRegister |= (Ipp32s)0;
        bs->m_base.m_nReadyBits --;
    }

    switch (bs->m_base.m_nReadyBits >> 3)
    {
        case 0:
            *(bs->m_base.m_pbs) = (Ipp8u)((Ipp32u)bs->m_base.m_nRegister>>24);
            *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>16);
            *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister>>8);
            *(bs->m_base.m_pbs+3) = (Ipp8u)(bs->m_base.m_nRegister);
            bs->m_base.m_pbs += 4;
            break;
        case 1:
            *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>16);
            *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister>>8);
            *(bs->m_base.m_pbs+2) = (Ipp8u)(bs->m_base.m_nRegister);
            bs->m_base.m_pbs += 3;
            break;
        case 2:
            *(bs->m_base.m_pbs) = (Ipp8u)(bs->m_base.m_nRegister>>8);
            *(bs->m_base.m_pbs+1) = (Ipp8u)(bs->m_base.m_nRegister);
            bs->m_base.m_pbs += 2;
            break;
        case 3:
            *(bs->m_base.m_pbs++) = (Ipp8u)(bs->m_base.m_nRegister);
            break;
    }
    bs->m_base.m_nRegister = 0;
    bs->m_base.m_nReadyBits = 32;
    //H264BsReal_ByteAlignWithZeros(state);
}
#endif

void H264BsFake_TerminateEncode_CABAC(void*)
{
}

void H264BsFake_CopyContext_CABAC(
    void* state,
    H264BsBase* bstrm,
    Ipp32s isFrame,
    Ipp32s is8x8)
{
    H264BsFake* bs = (H264BsFake *)state;
    memcpy(&bs->m_base.context_array[0], &bstrm->context_array[0], 105*sizeof(CABAC_CONTEXT));
    memcpy(&bs->m_base.context_array[227], &bstrm->context_array[227], 49*sizeof(CABAC_CONTEXT));
    if (isFrame)
        memcpy(&bs->m_base.context_array[105], &bstrm->context_array[105], 122*sizeof(CABAC_CONTEXT));
    else
        memcpy(&bs->m_base.context_array[277], &bstrm->context_array[277], 122*sizeof(CABAC_CONTEXT));

    if (is8x8)
    {
        memcpy(&bs->m_base.context_array[426], &bstrm->context_array[426], 10*sizeof(CABAC_CONTEXT));
        if (isFrame)
            memcpy(&bs->m_base.context_array[402], &bstrm->context_array[402], 24*sizeof(CABAC_CONTEXT));
        else
            memcpy(&bs->m_base.context_array[436], &bstrm->context_array[436], 24*sizeof(CABAC_CONTEXT));
    }

    bs->m_base.context_array[276] = bstrm->context_array[276]; //end of slice flag
    bs->m_base.context_array[399] = bstrm->context_array[399]; //transform 8x8 flag
    bs->m_base.context_array[400] = bstrm->context_array[400]; //transform 8x8 flag
    bs->m_base.context_array[401] = bstrm->context_array[401]; //transform 8x8 flag
    bs->m_base.m_lcodIRange = bstrm->m_lcodIRange;
}

void H264BsReal_EncodeUnaryRepresentedSymbol_CABAC(
    H264BsReal* state,
    Ipp8u* ctx,
    Ipp32s ctxIdx,
    Ipp32s code,
    Ipp32s suppremum)
{
    if (code == 0)
    {
        H264BsReal_EncodeSingleBin_CABAC(state, ctx, 0);
    }
    else
    {
        H264BsReal_EncodeSingleBin_CABAC(state, ctx, 1);
        Ipp32s temp=code;
        while ((--temp) > 0)
            H264BsReal_EncodeSingleBin_CABAC(state, ctx + ctxIdx, 1);
        if (code < suppremum)
            H264BsReal_EncodeSingleBin_CABAC(state, ctx + ctxIdx, 0);
    }
}

void H264BsReal_EncodeExGRepresentedLevels_CABAC(
    void* state,
    Ipp8u* ctx,
    Ipp32s code)
{
    /* 2^(i+1)-2 except last=2^(i+1)-1 */
    static Ipp32u c[14] = {0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16383};

    if (code == 0)
    {
        H264BsReal_EncodeSingleBin_CABAC(state, ctx, 0);
    }
    else
    {
        if (code < 13)
        {
            H264BsReal_EncodeBins_CABAC(state, ctx, c[code], code + 1);
        }
        else
        {
            H264BsReal_EncodeBins_CABAC(state, ctx, c[13], 13);
            H264BsReal_EncodeExGRepresentedSymbol_CABAC(state, code - 13, 0);
        }
    }
}

void H264BsReal_EncodeExGRepresentedMVS_CABAC(
    void* state,
    Ipp8u* ctx,
    Ipp32s code)
{
    Ipp32s tempval, tempindex;
    Ipp32s bin = 1;
    Ipp32s inc;

    if (code == 0)
    {
        H264BsReal_EncodeSingleBin_CABAC(state, ctx, 0);
        return;
    }
    else
    {
        H264BsReal_EncodeSingleBin_CABAC(state, ctx, 1);
        tempval = code;
        tempindex = 1;
        inc = 1;
        while (((--tempval) > 0) && (++tempindex <= 8))
        {
            H264BsReal_EncodeSingleBin_CABAC(state, ctx + inc, 1);
            if ((++bin) == 2)
                inc++;
            if (bin == 3)
                inc++;
        }

        if (code < 8)
            H264BsReal_EncodeSingleBin_CABAC(state, ctx + inc, 0);
        else
            H264BsReal_EncodeExGRepresentedSymbol_CABAC(state, code - 8, 3);
    }
}

void H264BsFake_EncodeExGRepresentedMVS_CABAC(
    void* state,
    Ipp8u* ctx,
    Ipp32s code)
{
    H264BsFake* bs = (H264BsFake *)state;
    if (code == 0)
    {
        H264BsFake_EncodeSingleBin_CABAC(state, ctx, 0);
        return;
    }
    else
    {
        Ipp32s tempval, tempindex;
        //Ipp32s bin=1;
        Ipp32s inc;
        H264BsFake_EncodeSingleBin_CABAC(state, ctx, 1);
        tempval = code;
        tempindex = 1;
        inc = 1;
        while (((--tempval) > 0) && (++tempindex <= 8))
        {
            H264BsFake_EncodeSingleBin_CABAC(state, ctx + inc, 1);
            if (inc < 3)
                inc++;
            //if ((++bin) == 2)
                //inc++;
            //if (bin == 3)
                //inc++;
        }

        if (code < 8)
        {
            H264BsFake_EncodeSingleBin_CABAC(state, ctx + inc, 0);
        }
        else
        {
            //H264BsFake_EncodeExGRepresentedSymbol_CABAC(state, code - 8, 3);
            if (code >= 65536 - 1 + 8)
            {
                bs->m_base.m_bitOffset += 256 * 32;
                code >>= 16;
            }

            if (code >= 256 - 1 + 8)
            {
                bs->m_base.m_bitOffset += 256 * 16;
                code >>= 8;
            }

            bs->m_base.m_bitOffset += bitcount_EG3[code];
        }
    }
}

void H264BsReal_EncodeExGRepresentedSymbol_CABAC(
    void* state,
    Ipp32s code,
    Ipp32s log2ex)
{
    for (;;)
    {
        if (code>= (1<<log2ex))
        {
            H264BsReal_EncodeBypass_CABAC(state, 1);
            code -= (1<<log2ex);
            log2ex++;
        }
        else
        {
            H264BsReal_EncodeBypass_CABAC(state, 0);
            while (log2ex--)
                H264BsReal_EncodeBypass_CABAC(state, (code >> log2ex) & 1);
            return;
        }
    }
}

void H264BsReal_InitializeContextVariablesIntra_CABAC(
    void* state,
    Ipp32s SliceQPy)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32s l;

    // See subclause 9.3.1.1 of H.264 standard

    SliceQPy = Clip3(0, 51, SliceQPy);

    // Initialize context(s) for mb_type (SI & I slices)
    for (l = 0;l <= 10;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_0_10[l - 0].m,
                          M_and_N_for_ctxIdx_0_10[l - 0].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                        );
    };

    // Initialize context(s) for mb_qp_delta &
    // intra_chroma_pred_mode & prev_intra4x4_pred_mode_flag &
    // rem_intra4x4_pred_mode
    for (l = 60;l <= 69;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_60_69[l - 60].m,
                          M_and_N_for_ctxIdx_60_69[l - 60].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                        );
    };

    // Initialize context(s) for mb_field_decoding_flag &
    // coded_block_pattern(luma) & coded_block_pattern(chroma) &
    // coded_block_flag (SI & I slices)
    for (l = 70;l <= 104;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_70_104_intra[l - 70].m,
                          M_and_N_for_ctxIdx_70_104_intra[l - 70].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for significant_coeff_flag[] (frame coded)
    for (l = 105;l <= 165;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_105_165_intra[l - 105].m,
                          M_and_N_for_ctxIdx_105_165_intra[l - 105].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for last_significant_coeff_flag[] (frame coded)
    for (l = 166;l <= 226;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_166_226_intra[l - 166].m,
                          M_and_N_for_ctxIdx_166_226_intra[l - 166].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for coeff_abs_level_minus1[]
    for (l = 227;l <= 275;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_227_275_intra[l - 227].m,
                          M_and_N_for_ctxIdx_227_275_intra[l - 227].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // ctxIdx equal to 276 is associated the end_of_slice_flag
    // Initial values associated with ctxIdx equal to 276
    // are specified to be pStateIdx = 63 and valMPS = 0
    bs->m_base.context_array[276] = 63;
    //context_array[276].valMPS = 0;

    // Initalize context(s) for significant_coeff_flag[] (field coded)
    for (l = 277;l <= 337;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_277_337_intra[l - 277].m,
                          M_and_N_for_ctxIdx_277_337_intra[l - 277].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for last_significant_coeff_flag[] (field coded)
    for (l = 338;l <= 398;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_338_398_intra[l - 338].m,
                          M_and_N_for_ctxIdx_338_398_intra[l - 338].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    for (l = 399;l <= 401;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_399_401_intra[l - 399].m,
                          M_and_N_for_ctxIdx_399_401_intra[l - 399].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };
    for (l = 402;l <= 459;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_402_459_intra[l - 402].m,
                          M_and_N_for_ctxIdx_402_459_intra[l - 402].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    H264BsReal_ResetBitStream_CABAC(state);
} //void H264Bitstream::InitializeContextVariablesIntra_CABAC(Ipp32s SliceQPy)

// ---------------------------------------------------------------------------

void H264BsReal_InitializeContextVariablesInter_CABAC(
    void* state,
    Ipp32s SliceQPy,
    Ipp32s cabac_init_idc)
{
    H264BsReal* bs = (H264BsReal *)state;
    Ipp32s l;

    // See subclause 9.3.1.1 of H.264 standard

    SliceQPy = Clip3(0, 51, SliceQPy);
    // Initialize context(s) for mb_skip_flag & mb_type (P & SP slices)
    // & sub_mb_pred (P & SP slices)
    for (l = 11;l <= 23;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_11_23[l - 11][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_11_23[l - 11][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initialize context(s) for mb_skip_flag & mb_type (B slices)
    // & sub_mb_pred (B slices)
    for (l = 24;l <= 39;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_24_39[l - 24][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_24_39[l - 24][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initialize context(s) for mvd_10 & mvd_11
    for (l = 40;l <= 53;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_40_53[l - 40][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_40_53[l - 40][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initialize context(s) for ref_idx_10 & ref_idx_11
    for (l = 54;l <= 59;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_54_59[l - 54][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_54_59[l - 54][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initialize context(s) for mb_qp_delta &
    // intra_chroma_pred_mode & prev_intra4x4_pred_mode_flag &
    // rem_intra4x4_pred_mode
    for (l = 60;l <= 69;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_60_69[l - 60].m,
                          M_and_N_for_ctxIdx_60_69[l - 60].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for mb_field_decoding_flag &
    // coded_block_pattern(luma) & coded_block_pattern(chroma) &
    // coded_block_flag (P, SP & B slices)
    for (l = 70;l <= 104;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_70_104_inter[l - 70][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_70_104_inter[l - 70][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for significant_coeff_flag[] (frame coded)
    for (l = 105;l <= 165;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_105_165_inter[l - 105][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_105_165_inter[l - 105][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    }

    // Initalize context(s) for last_significant_coeff_flag[] (frame coded)
    for (l = 166;l <= 226;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_166_226_inter[l - 166][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_166_226_inter[l - 166][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for coeff_abs_level_minus1[]
    for (l = 227;l <= 275;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_227_275_inter[l - 227][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_227_275_inter[l - 227][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for significant_coeff_flag[] (field coded)
    for (l = 277;l <= 337;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_277_337_inter[l - 277][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_277_337_inter[l - 277][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    // Initalize context(s) for last_significant_coeff_flag[] (field coded)
    for (l = 338;l <= 398;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_338_398_inter[l - 338][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_338_398_inter[l - 338][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    for (l = 399;l <= 401;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_399_401_inter[l - 399][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_399_401_inter[l - 399][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };
    for (l = 402;l <= 459;l += 1)
    {
        InitializeContext(&(bs->m_base.context_array[l]),
                          M_and_N_for_ctxIdx_402_459_inter[l - 402][cabac_init_idc].m,
                          M_and_N_for_ctxIdx_402_459_inter[l - 402][cabac_init_idc].n,
                          SliceQPy
#ifdef STORE_CABAC_BITS
#ifdef CABAC_CONTEXTS_COMP
                         ,l
#endif
#endif
                         );
    };

    H264BsReal_ResetBitStream_CABAC(state);
} //void H264Bitstream::InitializeContextVariablesInter_CABAC(Ipp32s SliceQPy, Ipp32s cabac_init_idc)

// ---------------------------------------------------------------------------

#endif //UMC_ENABLE_H264_VIDEO_ENCODER
